{"version":3,"file":"static/js/7095.9cf3f73e.chunk.js","mappings":"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","sources":["constants/Colors.js","store/actions/properties.js"],"sourcesContent":["export default {\r\n  primary: 'rgba(125, 43, 233, 1)',\r\n  accent: '#FFC107'\r\n};\r\n","import _ from \"lodash\";\r\nimport moment from \"moment\";\r\nimport { API_URL, GEO_API, PROPERTY_API } from \"../../constants/Config\";\r\nimport * as events from \"../events\";\r\n\r\nconst getUser = () => {\r\n  if (localStorage.getItem(\"@shadowuser\") !== null) {\r\n    const user = JSON.parse(localStorage.getItem(\"@shadowuser\"));\r\n    return user;\r\n  }\r\n};\r\n\r\nexport const filtersTotal = () => {\r\n  const storedFilters = localStorage.getItem(\"@propertyFilter\");\r\n  let total = 0;\r\n  if (storedFilters) {\r\n    const filters = JSON.parse(storedFilters);\r\n    for (const filter in filters) {\r\n      // console.log(\"FILTER\", filter, filters[filter])\r\n      if (filter === \"date\") {\r\n        const date = filters[\"date\"];\r\n        if (date.from && date.to) {\r\n          total = total + 1;\r\n        }\r\n      } else if (filter === \"sort\") {\r\n        if (filters[\"sort\"] !== \"\") {\r\n          total = total + 1;\r\n        }\r\n      } else if (filter === \"order\") {\r\n        if (filters[\"order\"] === \"desc\") {\r\n          total = total + 1;\r\n        }\r\n      } else if (filter === \"ts\") {\r\n        continue;\r\n      } else {\r\n        total = total + filters[filter].length;\r\n      }\r\n    }\r\n  }\r\n  return total;\r\n};\r\n\r\nexport const filtersLastUpdated = () => {\r\n  const storedFilters = localStorage.getItem(\"@propertyFilter\");\r\n  if (storedFilters) {\r\n    const filters = JSON.parse(storedFilters);\r\n    return filters[\"ts\"] ? filters[\"ts\"] : moment().valueOf();\r\n  }\r\n  return null; //moment().format(\"DDMMYYYY\");\r\n};\r\n\r\nexport const getFilter = async (created) => {\r\n  const filter = localStorage.getItem(\"@propertyFilter\");\r\n  if (!filter || (filter && Object.keys(filter).length < 2)) {\r\n    return {\r\n      fromDate: moment(created).format(\"YYYY-MM-DD\"),\r\n      toDate: moment().format(\"YYYY-MM-DD\"),\r\n      filteredTags: [],\r\n      filteredStatus: [],\r\n      filteredBedrooms: [],\r\n      filteredBathrooms: [],\r\n      filteredFloors: [],\r\n      filteredBuiltyear: [],\r\n      filteredSqft: [],\r\n      filteredAcre: [],\r\n      filteredEv: [],\r\n      sortBy: \"tid\",\r\n      orderBy: \"desc\",\r\n      isUserFilter: false,\r\n    };\r\n  }\r\n  const filterData = JSON.parse(filter);\r\n  return filterData;\r\n};\r\n\r\nexport const fetchProperties = (page = 1, limit = 100, search = \"\") => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const isFiltered = filtersTotal() > 0;\r\n    let storedFilter = localStorage.getItem(\"@propertyFilter\");\r\n    const filter = {};\r\n    let sort = { _id: -1 };\r\n    if (isFiltered) {\r\n      storedFilter = JSON.parse(storedFilter);\r\n      if (storedFilter.date && storedFilter.date.from && storedFilter.date.to) {\r\n        filter[\"fromdate\"] = moment(storedFilter.date.from)\r\n          .startOf(\"day\")\r\n          .toISOString();\r\n        filter[\"todate\"] = moment(storedFilter.date.to)\r\n          .endOf(\"day\")\r\n          .toISOString();\r\n      }\r\n\r\n      if (storedFilter.tags.length > 0) {\r\n        filter[\"tags\"] = storedFilter.tags;\r\n      }\r\n\r\n      if (storedFilter.status.length > 0) {\r\n        filter[\"status\"] = storedFilter.status;\r\n      }\r\n\r\n      if (storedFilter.bath.length > 0) {\r\n        filter[\"bath\"] = storedFilter.bath.map((b) => {\r\n          if (b === \"10+\") {\r\n            b = 10;\r\n          }\r\n          return parseInt(b);\r\n        });\r\n      }\r\n\r\n      if (storedFilter.bed.length > 0) {\r\n        filter[\"bed\"] = storedFilter.bed.map((b) => {\r\n          if (b === \"10+\") {\r\n            b = 10;\r\n          }\r\n          return parseInt(b);\r\n        });\r\n      }\r\n\r\n      if (storedFilter.acre.length > 0) {\r\n        filter[\"acre\"] = storedFilter.acre.map((a) => {\r\n          // a = a.replace(\"+\", \"\");\r\n          // a = a.replace(\"<\", \"\");\r\n          // if (a === \"<0.4999\") {\r\n          //   a = 0.4999;\r\n          // }\r\n          return a;\r\n        });\r\n      }\r\n     \r\n\r\n      if (storedFilter.sqft.length > 0) {\r\n        filter[\"sqft\"] = storedFilter.sqft.map((a) => {\r\n          // if (a === \"20000+\") {\r\n            // a = 20000;\r\n          // }\r\n          return a;\r\n        });\r\n      }\r\n\r\n      if (storedFilter.year.length > 0) {\r\n        filter[\"yearbuilt\"] = storedFilter.year.map((f) => f.toString());\r\n      }\r\n\r\n      if (storedFilter.ev.length > 0) {\r\n        filter[\"ev\"] = storedFilter.ev.map((a) => {\r\n          a = a.replace(\",\", \"\");\r\n          a = a.replace(\",\", \"\");\r\n          a = a.replace(\",\", \"\");\r\n          a = a.replace(\"$\", \"\");\r\n          a = a.replace(\"+\", \"\");\r\n          a = a.replace(\"0-99999\", \"99999\");\r\n          return parseInt(a);\r\n        });\r\n      }\r\n\r\n      // let sortBy = storedFilter.sort;\r\n      if (storedFilter.sort !== \"\") {\r\n        console.log(storedFilter.sort, storedFilter.order);\r\n        let sortBy = storedFilter.sort;\r\n\r\n        if (storedFilter.sort === \"ser\") {\r\n          sortBy = \"createdUser.firstname\";\r\n        }\r\n\r\n        sort = {\r\n          [sortBy]: storedFilter.order === \"desc\" ? -1 : 1,\r\n        };\r\n      }\r\n    }\r\n\r\n    const body = JSON.stringify({\r\n      skip: page === 1 ? 0 : (page - 1) * limit,\r\n      limit: parseInt(limit),\r\n      sort,\r\n      search,\r\n      fields: {\r\n        _id: 1,\r\n        name: 1,\r\n        propertyaddress: 1,\r\n        owneraddress: 1,\r\n        // campaign: 1,\r\n        // mailers: 1,\r\n        // history: 1,\r\n        // notes: 1,\r\n        // emails: 1,\r\n        // phones: 1,\r\n        coords: 1,\r\n        bed: 1,\r\n        bath: 1,\r\n        floor: 1,\r\n        sqft: 1,\r\n        acre: 1,\r\n        ev: 1,\r\n        yearbuilt: 1,\r\n        status: 1,\r\n        tags: 1,\r\n        apn: 1,\r\n        tid: 1,\r\n        mid: 1,\r\n        pic: 1,\r\n        created: 1,\r\n        modified: 1,\r\n        \"createdUser._id\": 1,\r\n        \"createdUser.firstname\": 1,\r\n        \"createdUser.lastname\": 1,\r\n        \"createdUser.pic\": 1,\r\n      },\r\n      filter,\r\n    });\r\n\r\n    try {\r\n      const response = await fetch(`${API_URL}/properties/get`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n        body,\r\n      });\r\n\r\n      if (!response.ok) {\r\n        console.log(await response.json());\r\n        throw new Error(\"Something went wrong!\");\r\n      }\r\n      const resData = await response.json();\r\n\r\n      dispatch({\r\n        type: events.SET_PROPERTIES,\r\n        properties: resData.data ? resData.data : [],\r\n        page,\r\n        total: resData.count,\r\n      });\r\n\r\n      return resData.count ? resData.count : 0;\r\n    } catch (err) {\r\n      console.log(\"fetchProperties Error \", err);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nexport const fetchNotes = (id, page, limit) => {\r\n  return async (dispatch, getState) => {\r\n    // any async code you want!\r\n    const { token } = getUser();\r\n    try {\r\n      const response = await fetch(`${API_URL}/deal/notes-list/${id}`, {\r\n        method: \"GET\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(\"Something went wrong!\");\r\n      }\r\n\r\n      const resData = await response.json();\r\n\r\n      dispatch({\r\n        type: events.SET_PROPERTIES_NOTES,\r\n        data: resData.data,\r\n      });\r\n    } catch (err) {\r\n      // send to custom analytics server\r\n      console.log(\"fetchNotes Error \", err);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nexport const fetchStatus = (page = 1, limit = 0) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const body = JSON.stringify({\r\n      skip: page === 1 ? 0 : (page - 1) * limit,\r\n      limit,\r\n      sort: { default: -1 },\r\n    });\r\n    try {\r\n      const response = await fetch(`${API_URL}/status/get`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n        body,\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(\"Something went wrong!\");\r\n      }\r\n\r\n      const resData = await response.json();\r\n      if (resData.data) {\r\n        dispatch({\r\n          type: events.SET_STATUS_LIST,\r\n          data: resData.data,\r\n        });\r\n      }\r\n    } catch (err) {\r\n      // send to custom analytics server\r\n      console.log(\"fetchStatus Error \", err);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nexport const fetchRoutes = (page, limit) => {\r\n  return async (dispatch, getState) => {\r\n    // any async code you want!\r\n    const { token } = getUser();\r\n    try {\r\n      const response = await fetch(`${API_URL}/deal/drived-routes-list`, {\r\n        method: \"GET\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(\"Something went wrong!\");\r\n      }\r\n\r\n      const resData = await response.json();\r\n\r\n      dispatch({\r\n        type: events.SET_STATUS_LIST,\r\n        data: resData.data,\r\n      });\r\n    } catch (err) {\r\n      // send to custom analytics server\r\n      console.log(\"fetchRoutes Error \", err);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nexport const fetchRouteById = (id) => {\r\n  return async (dispatch, getState) => {\r\n    // any async code you want!\r\n    // const { token } = getUser();\r\n    try {\r\n      const response = await fetch(\r\n        `https://realtime.shadow.properties/route/${id}`,\r\n        {\r\n          method: \"GET\",\r\n          headers: {\r\n            \"Content-Type\": \"application/json\",\r\n            // Authorization: 'Bearer ' + token\r\n          },\r\n        }\r\n      );\r\n\r\n      if (!response.ok) {\r\n        throw new Error(\"Something went wrong!\");\r\n      }\r\n\r\n      const resData = await response.json();\r\n\r\n      return resData.data;\r\n    } catch (err) {\r\n      // send to custom analytics server\r\n      console.log(\"fetchRouteById Error \", err);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nexport const fetchTags = (page = 1, limit = 0) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const body = JSON.stringify({\r\n      skip: page === 1 ? 0 : (page - 1) * limit,\r\n      limit,\r\n      sort: { default: -1 },\r\n    });\r\n\r\n    try {\r\n      const response = await fetch(`${API_URL}/tags/get`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n        body,\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const e = await response.json();\r\n        let msg = \"Something went wrong!\";\r\n        if (e.error) {\r\n          msg = e.error;\r\n        }\r\n        throw new Error(msg);\r\n      }\r\n\r\n      const resData = await response.json();\r\n      if (resData.data) {\r\n        dispatch({\r\n          type: events.SET_TAGS,\r\n          data: resData.data,\r\n        });\r\n      }\r\n    } catch (err) {\r\n      console.log(\"fetchTags Error \", err);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nexport const fetchPropertyById = (_id) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    try {\r\n      const response = await fetch(`${API_URL}/properties/${_id}`, {\r\n        method: \"GET\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n      });\r\n\r\n      if (!response.ok) {\r\n        console.log(await response.json());\r\n        throw new Error(\"Something went wrong!\");\r\n      }\r\n\r\n      const resData = await response.json();\r\n      if (resData.data) {\r\n        dispatch({\r\n          type: events.FETCHED_PROPERTY,\r\n          data: resData.data,\r\n        });\r\n      }\r\n      return resData.data;\r\n    } catch (err) {\r\n      // send to custom analytics server\r\n      console.log(\"fetchPropertyById Error \", err);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nexport const setDefaultImage = (data, socket = null) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { _id } = data;\r\n    delete data._id;\r\n    const response = await fetch(`${API_URL}/properties/${_id}`, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      console.log(\"setDefaultImage\", errorResData.error);\r\n      let message = \"Something went wrong!\";\r\n      if (errorResData.error) {\r\n        throw new Error(errorResData.error);\r\n      } else {\r\n        throw new Error(message);\r\n      }\r\n    }\r\n    const resData = await response.json();\r\n    if (resData.data) {\r\n      if (socket) {\r\n        socket.emit(\"property:updated\", resData.data);\r\n      }\r\n      const availableProperties = getState().properties.availableProperties;\r\n      refreshProperty(dispatch, availableProperties, resData.data);\r\n    }\r\n  };\r\n};\r\n\r\nexport const updatePropertyStatus = (data, socket = null) => {\r\n  return async (dispatch, getState) => {\r\n    try {\r\n      const { token } = getUser();\r\n      const { _id } = data;\r\n      delete data._id;\r\n      const response = await fetch(`${API_URL}/properties/${_id}`, {\r\n        method: \"PATCH\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n        body: JSON.stringify(data),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errRes = await response.json();\r\n        console.log(\"updatePropertyStatus\", errRes.error);\r\n        let message = \"Something went wrong!\";\r\n        if (errRes.error) {\r\n          throw new Error(errRes.error);\r\n        } else {\r\n          throw new Error(message);\r\n        }\r\n      }\r\n      const resData = await response.json();\r\n      const availableProperties = getState().properties.availableProperties;\r\n      if (socket) {\r\n        socket.emit(\"property:updated\", resData.data);\r\n      }\r\n      refreshProperty(dispatch, availableProperties, resData.data);\r\n      return resData.data;\r\n    } catch (err) {\r\n      throw new Error(err.message);\r\n    }\r\n  };\r\n};\r\n\r\nexport const updatePropertyTag = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { _id } = data;\r\n    delete data._id;\r\n    const response = await fetch(`${API_URL}/properties/${_id}`, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      console.log(\"setDefaultImage\", errorResData.error);\r\n      let message = \"Something went wrong!\";\r\n      if (errorResData.error) {\r\n        throw new Error(errorResData.error);\r\n      } else {\r\n        throw new Error(message);\r\n      }\r\n    }\r\n    const resData = await response.json();\r\n    const availableProperties = getState().properties.availableProperties;\r\n    refreshProperty(dispatch, availableProperties, resData.data);\r\n  };\r\n};\r\n\r\nexport const savePropertyTag = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const response = await fetch(`${API_URL}/tags/add`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      console.log(\"setDefaultImage\", errorResData.error);\r\n      let message = \"Something went wrong!\";\r\n      if (errorResData.error) {\r\n        throw new Error(errorResData.error);\r\n      } else {\r\n        throw new Error(message);\r\n      }\r\n    }\r\n    // const resData = await response.json();\r\n\r\n    await fetchTags(1, 0);\r\n  };\r\n};\r\n\r\nconst refreshProperty = (dispatch, availableProperties, updatedProperty) => {\r\n  dispatch({\r\n    type: events.FETCHED_PROPERTY,\r\n    data: updatedProperty,\r\n  });\r\n\r\n  const refreshedProperties = availableProperties.map((item) => {\r\n    if (item._id === updatedProperty._id) {\r\n      for (const i in item) {\r\n        if (Object.keys(updatedProperty).includes(i)) {\r\n          item[i] = updatedProperty[i];\r\n        }\r\n      }\r\n    }\r\n    return item;\r\n  });\r\n\r\n  dispatch({\r\n    type: events.SET_PROPERTIES,\r\n    properties: refreshedProperties,\r\n  });\r\n};\r\n\r\nexport const savePropertyNote = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n\r\n    const { _id } = data;\r\n    delete data._id;\r\n    const response = await fetch(`${API_URL}/properties/${_id}`, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      console.log(\"savePropertyNote\", errorResData.error);\r\n      let message = \"Something went wrong!\";\r\n      if (errorResData.error) {\r\n        throw new Error(errorResData.error);\r\n      } else {\r\n        throw new Error(message);\r\n      }\r\n    }\r\n    const resData = await response.json();\r\n    if (resData.data) {\r\n      // const pipelines = getState().pipelines.pipelines;\r\n      // const availableProperties = getState().properties.availableProperties;\r\n      // refreshProperty(dispatch, availableProperties, resData.data);\r\n      // if (pipelines && pipelines.length > 0) {\r\n      dispatch({\r\n        type: events.ADD_PIPELINE_PROPERTY_NOTES,\r\n        data: resData.data,\r\n      });\r\n      // }\r\n      return resData.data;\r\n    }\r\n  };\r\n};\r\n\r\nexport const saveMailingAddress = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { _id } = data;\r\n    delete data._id;\r\n    let url = `${API_URL}/properties/${_id}`;\r\n\r\n    const response = await fetch(url, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const err = await response.json();\r\n      console.log(\"saveMailingAddress\", err.error);\r\n      let message = \"Something went wrong!\";\r\n      if (err.error) {\r\n        throw new Error(err.error);\r\n      }\r\n      throw new Error(message);\r\n    }\r\n    const resData = await response.json();\r\n    const availableProperties = getState().properties.availableProperties;\r\n    refreshProperty(dispatch, availableProperties, resData.data);\r\n  };\r\n};\r\n\r\nexport const savePhoneNumbers = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { _id } = data;\r\n    delete data._id;\r\n    let url = `${API_URL}/properties/${_id}`;\r\n    const response = await fetch(url, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      console.log(\"savePhoneNumbers\", errorResData.error);\r\n      let message = \"Something went wrong!\";\r\n      if (errorResData.error) {\r\n        throw new Error(errorResData.error);\r\n      } else {\r\n        throw new Error(message);\r\n      }\r\n    }\r\n    const resData = await response.json();\r\n    const availableProperties = getState().properties.availableProperties;\r\n    refreshProperty(dispatch, availableProperties, resData.data);\r\n  };\r\n};\r\n\r\nexport const saveEmails = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { fetchedProperty: property, availableProperties } =\r\n      getState().properties;\r\n    const { _id } = data;\r\n    delete data._id;\r\n    const campaign =\r\n      property.campaign && Object.keys(property.campaign).length > 0\r\n        ? property.campaign\r\n        : null;\r\n    let url = `${API_URL}/properties/${_id}`;\r\n    const response = await fetch(url, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify({ ...data, campaign }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      console.log(\"saveEmails\", errorResData.error);\r\n      let message = \"Something went wrong!\";\r\n      if (errorResData.error) {\r\n        throw new Error(errorResData.error);\r\n      } else {\r\n        throw new Error(message);\r\n      }\r\n    }\r\n    const resData = await response.json();\r\n    refreshProperty(dispatch, availableProperties, resData.data);\r\n  };\r\n};\r\n\r\nexport const updatePostCardName = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { _id } = data;\r\n    delete data._id;\r\n    const response = await fetch(`${API_URL}/properties/${_id}`, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      console.log(\"updatePostCardName\", errorResData.error);\r\n      let message = \"Something went wrong!\";\r\n      if (errorResData.error) {\r\n        throw new Error(errorResData.error);\r\n      } else {\r\n        throw new Error(message);\r\n      }\r\n    }\r\n    const resData = await response.json();\r\n    if (resData.data) {\r\n      dispatch({\r\n        type: events.FETCHED_PROPERTY,\r\n        data: resData.data,\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\nexport const updateOutreachCampaignSettings = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { _id } = data;\r\n    delete data._id;\r\n    const response = await fetch(`${API_URL}/properties/${_id}`, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorRes = await response.json();\r\n      let message = \"Something went wrong!\";\r\n      if (errorRes && errorRes.error) {\r\n        message = errorRes.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n    const availableProperties = getState().properties.availableProperties;\r\n    refreshProperty(dispatch, availableProperties, resData.data);\r\n    dispatch({\r\n      type: events.FETCHED_PROPERTY,\r\n      data: resData.data,\r\n    });\r\n  };\r\n};\r\n\r\nexport const stopCampaign = (data) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { _id } = data;\r\n    delete data._id;\r\n    const response = await fetch(`${API_URL}/lists/properties/stop/${_id}`, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorRes = await response.json();\r\n      let message = \"Something went wrong!\";\r\n      if (errorRes && errorRes.error) {\r\n        message = errorRes.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n    const availableProperties = getState().properties.availableProperties;\r\n    refreshProperty(dispatch, availableProperties, resData.data);\r\n    dispatch({\r\n      type: events.FETCHED_PROPERTY,\r\n      data: resData.data,\r\n    });\r\n  };\r\n};\r\n\r\nexport const stopPropertiesCampaign = async (data, dispatch = null) => {\r\n  try {\r\n    const { token } = getUser();\r\n    const response = await fetch(`${API_URL}/lists/properties/stopcampaign`, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorRes = await response.json();\r\n      let message = \"Something went wrong!\";\r\n      if (errorRes && errorRes.error) {\r\n        message = errorRes.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n\r\n    console.log(\r\n      \"stopPropertiesCampaign\",\r\n      resData.property,\r\n      data.manualcampaign\r\n    );\r\n    if (resData.property && data.manualcampaign) {\r\n      dispatch({\r\n        type: events.FETCHED_PROPERTY,\r\n        data: resData.property,\r\n      });\r\n    }\r\n\r\n    return resData.success ? true : false;\r\n  } catch (err) {\r\n    throw new Error(err.message);\r\n  }\r\n};\r\n\r\nexport const removeProperties = async (data) => {\r\n  try {\r\n    const { token } = getUser();\r\n    const { _id } = data;\r\n    delete data._id;\r\n    const response = await fetch(`${API_URL}/lists/properties/delete/${_id}`, {\r\n      method: \"DELETE\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorRes = await response.json();\r\n      let message = \"Something went wrong!\";\r\n      if (errorRes && errorRes.error) {\r\n        message = errorRes.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n    return resData.success ? true : false;\r\n  } catch (err) {\r\n    throw new Error(err.message);\r\n  }\r\n};\r\n\r\nexport const moveProperties = async (data) => {\r\n  try {\r\n    const { token } = getUser();\r\n    const response = await fetch(\r\n      `${API_URL}/lists/properties/move/${data.to}`,\r\n      {\r\n        method: \"PATCH\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n        body: JSON.stringify(data),\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      const errorRes = await response.json();\r\n      let message = \"Something went wrong!\";\r\n      if (errorRes && errorRes.error) {\r\n        message = errorRes.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n    console.log(resData);\r\n    return resData.success ? true : false;\r\n  } catch (err) {\r\n    throw new Error(err.message);\r\n  }\r\n};\r\n\r\nexport const setPropertiesCampaign = async (data) => {\r\n  try {\r\n    const { token } = getUser();\r\n    const response = await fetch(`${API_URL}/lists/properties/setcampaign`, {\r\n      method: \"PATCH\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorRes = await response.json();\r\n      let message = \"Something went wrong!\";\r\n      if (errorRes && errorRes.error) {\r\n        message = errorRes.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n    return resData.success ? true : false;\r\n  } catch (err) {\r\n    throw new Error(err.message);\r\n  }\r\n};\r\n\r\nexport const saveBulkProperty = (owner) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    if (!owner.name) {\r\n      throw new Error(\"owner not found\");\r\n    }\r\n\r\n    const phones = [];\r\n    const emails = [];\r\n    const addresses = [];\r\n    if (owner.propertyaddress !== \"\") {\r\n      const { address1, address2, city, state, zip } = parseAddress(\r\n        owner.propertyaddress\r\n      );\r\n      addresses.push({\r\n        address1: address1,\r\n        address2: address2,\r\n        fulladdress: owner.address,\r\n        city: city,\r\n        state: state,\r\n        zipcode: zip,\r\n        type: \"property\",\r\n        default: false,\r\n      });\r\n    }\r\n\r\n    if (owner.address.trim() !== \"\" && owner.address.match(/^[0-9a-z]+$/)) {\r\n      const { address1, address2, city, state, zip } = parseAddress(\r\n        owner.address\r\n      );\r\n      addresses.push({\r\n        address1: address1,\r\n        address2: address2,\r\n        fulladdress: owner.address,\r\n        city: city,\r\n        state: state,\r\n        zipcode: zip,\r\n        type: \"owner\",\r\n        default: false,\r\n      });\r\n    }\r\n\r\n    const ev = owner.ev.replace(\"$\", \"\").replace(/,/g, \"\");\r\n    let primaryowner = owner.name;\r\n    let owners = owner.name.split(\"&\");\r\n    if (owner.name.includes(\"&\")) {\r\n      if (owners.length > 0) {\r\n        owners = owners.map((o) => {\r\n          return o.trim();\r\n        });\r\n      }\r\n      primaryowner = owners[0].trim();\r\n    } else if (owner.name.includes(\";\")) {\r\n      owners = owner.name.split(\";\");\r\n      if (owners.length > 0) {\r\n        owners = owners.map((o) => {\r\n          let s = o.split(\",\");\r\n          let owner = s[0].trim();\r\n          if (s.length > 1) {\r\n            owner = s[1].trim() + \" \" + s[0].trim();\r\n          }\r\n          return owner;\r\n        });\r\n      }\r\n      primaryowner = owners[0].trim();\r\n    }\r\n\r\n    const property = {\r\n      name: primaryowner,\r\n      allowners: owner.name,\r\n      owners,\r\n      company: owner.company,\r\n      // trust: owner.trust,\r\n      phone: owner.phone,\r\n      email: owner.email,\r\n      phones,\r\n      emails,\r\n      addresses,\r\n      gender: owner.gender,\r\n      age_range: owner.age,\r\n      dob: owner.dob,\r\n      owneraddress: owner.address,\r\n      propertyaddress: owner.propertyaddress,\r\n      coords: owner.coords,\r\n      attributes: owner.attributes,\r\n      route_id: !global.route_id ? null : global.route_id,\r\n      bed: parseInt(owner.bed),\r\n      bath: parseInt(owner.bath),\r\n      floor: parseInt(owner.floor),\r\n      sqft: parseFloat(owner.sqft),\r\n      acre: parseFloat(owner.acre),\r\n      yearbuilt: parseInt(owner.yearbuilt),\r\n      ev: parseFloat(ev),\r\n      apn: owner.apn,\r\n      smartsearch: false,\r\n    };\r\n\r\n    const response = await fetch(`${API_URL}/properties/add`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(property),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      let message = \"something went wrong\";\r\n      if (errorResData.error) {\r\n        message = errorResData.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n    if (resData.data) {\r\n      dispatch({\r\n        type: events.CREATE_PROPERTY,\r\n        data: resData.data,\r\n      });\r\n      return { _id: resData.data._id, address: resData.data.coords };\r\n    } else {\r\n      return null;\r\n    }\r\n  };\r\n};\r\n\r\nexport const createProperty = (socket = null) => {\r\n  return async (dispatch, getState) => {\r\n    // any async code you want!\r\n    const { token } = getUser();\r\n    const address = getState().properties.lastFetchedAddress;\r\n    const fetchedOwner = getState().properties.lastFetchedOwner;\r\n    const {\r\n      // availableProperties: properties,\r\n      page,\r\n    } = getState().properties;\r\n    const owner = fetchedOwner;\r\n    // console.log(owner, \"createProperty address\");\r\n\r\n    if (!owner.name) {\r\n      throw new Error(\"Owner not found.\");\r\n    }\r\n\r\n    if (owner.name.match(/\\d+/g) || !owner.address) {\r\n      throw new Error(\"Owner not found.\");\r\n    }\r\n\r\n    const phones = [];\r\n    // if (owner.phone !== \"\") {\r\n    //   phones.push({\r\n    //     label: \"Landline\",\r\n    //     phone: owner.phone,\r\n    //   });\r\n    // }\r\n    const emails = [];\r\n    // if (owner.emails !== \"\") {\r\n    //   emails.push({\r\n    //     label: \"Owner\",\r\n    //     email: owner.email,\r\n    //   });\r\n    // }\r\n\r\n    const addresses = [];\r\n\r\n    if (\r\n      owner.propertyaddress &&\r\n      owner.propertyaddress.trim() !== \"\" &&\r\n      owner.propertyaddress.trim() !== owner.address.trim()\r\n    ) {\r\n      const { address1, address2, city, state, zip, country } = parseAddress(\r\n        owner.propertyaddress.trim()\r\n      );\r\n      addresses.push({\r\n        addid: owner.address,\r\n        address1: address1,\r\n        address2: address2,\r\n        fulladdress: owner.address,\r\n        city: city,\r\n        state: state,\r\n        zipcode: zip,\r\n        type: \"property\",\r\n        default: false,\r\n        country,\r\n      });\r\n    }\r\n\r\n    if (owner.address && owner.address.replace(/,/g, \"\").trim() !== \"\") {\r\n      // && owner.address.match(/^[0-9a-z]+$/)) {\r\n      // console.log(\"Owner address\", owner.address);\r\n      const { address1, address2, city, state, zip, country } = parseAddress(\r\n        owner.address.trim()\r\n      );\r\n      addresses.push({\r\n        addid: owner.address,\r\n        address1: address1,\r\n        address2: address2,\r\n        fulladdress: owner.address,\r\n        city: city,\r\n        state: state,\r\n        zipcode: zip,\r\n        type: \"owner\",\r\n        default: true,\r\n        country,\r\n      });\r\n    }\r\n\r\n    const ev = owner.ev.replace(\"$\", \"\").replace(/,/g, \"\");\r\n    let primaryowner = owner.name;\r\n    let owners = owner.name.split(\"&\");\r\n    if (owner.name.includes(\"&\")) {\r\n      if (owners.length > 0) {\r\n        owners = owners.map((o) => {\r\n          return o.trim();\r\n        });\r\n      }\r\n      primaryowner = owners[0].trim();\r\n    } else if (owner.name.includes(\";\")) {\r\n      owners = owner.name.split(\";\");\r\n      if (owners.length > 0) {\r\n        owners = owners.map((o) => {\r\n          let s = o.split(\",\");\r\n          let owner = s[0].trim();\r\n          if (s.length > 1) {\r\n            owner = s[1].trim() + \" \" + s[0].trim();\r\n          }\r\n          return owner;\r\n        });\r\n      }\r\n      primaryowner = owners[0].trim();\r\n    }\r\n\r\n    const property = {\r\n      name: primaryowner.trim(),\r\n      allowners: owner.name,\r\n      owners,\r\n      company: owner.company,\r\n      // trust: owner.trust,\r\n      phone: owner.phone,\r\n      email: owner.email,\r\n      phones,\r\n      emails,\r\n      addresses,\r\n      gender: owner.gender,\r\n      age_range: owner.age,\r\n      dob: owner.dob,\r\n      owneraddress: owner.address,\r\n      propertyaddress: owner.propertyaddress,\r\n      coords: address.location,\r\n      attributes: owner.attributes,\r\n      route_id: !global.route_id ? null : global.route_id,\r\n      bed: parseInt(owner.bed),\r\n      bath: parseInt(owner.bath),\r\n      floor: owner.floor.toString(),\r\n      sqft: parseFloat(owner.sqft),\r\n      acre: parseFloat(owner.acre),\r\n      yearbuilt: owner.yearbuilt.toString(),\r\n      ev: parseFloat(ev),\r\n      apn: owner.apn,\r\n      smartsearch: false,\r\n    };\r\n\r\n    const response = await fetch(`${API_URL}/properties/add`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Authorization: \"Bearer \" + token,\r\n      },\r\n      body: JSON.stringify(property),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorResData = await response.json();\r\n      let message = \"something went wrong\";\r\n      if (errorResData.error) {\r\n        message = errorResData.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n    // console.log(\"create Property\", resData);\r\n    if (resData.data) {\r\n      const {\r\n        property,\r\n        stateproperties,\r\n        zipproperties,\r\n        // mapproperty\r\n      } = resData.data;\r\n\r\n      if (socket) {\r\n        socket.emit(\"property:add\", resData.data);\r\n      }\r\n      // console.log(\"createProperty\", properties.length, page);\r\n\r\n      if (!page || page === 1) {\r\n        dispatch({\r\n          type: events.CREATE_PROPERTY,\r\n          data: property,\r\n        });\r\n      }\r\n\r\n      dispatch({\r\n        type: events.UPDATE_STATE_PROPERTIES,\r\n        data: stateproperties,\r\n      });\r\n\r\n      dispatch({\r\n        type: events.UPDATE_ZIP_PROPERTIES,\r\n        data: zipproperties,\r\n      });\r\n\r\n      dispatch({\r\n        type: events.ADD_MAP_PROPERTIES,\r\n        data: [property],\r\n      });\r\n\r\n      return property._id;\r\n    }\r\n  };\r\n};\r\n\r\nexport const addBulkProperties = (\r\n  address,\r\n  pipeline = null,\r\n  list = null,\r\n  socket = null,\r\n  autosmartsearch = false\r\n) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { profile } = getState().auth;\r\n    let added = 0;\r\n    if (pipeline === \"None\") {\r\n      pipeline = null;\r\n    }\r\n    if (list === \"None\") {\r\n      list = null;\r\n    }\r\n    // let notfound = 0;\r\n    const price =\r\n      (profile && profile.plan && profile.plan.smartsearch) ||\r\n      (profile && profile.freetrial && profile.freetrial.smartsearch) ||\r\n      0;\r\n\r\n    if (price === 0) {\r\n      throw new Error(\"Cannot do smartsearch, subscription details not found.\");\r\n    }\r\n\r\n    try {\r\n      const response = await fetch(`${API_URL}/properties/bulkadd`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n        body: JSON.stringify({\r\n          address,\r\n          pipeline,\r\n          list,\r\n          route_id: !global.route_id ? null : global.route_id,\r\n          autosmartsearch,\r\n          price,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errRes = await response.json();\r\n        let message = \"something went wrong\";\r\n        if (errRes.error) {\r\n          message = errRes.error;\r\n        }\r\n        throw new Error(message);\r\n      }\r\n\r\n      const resData = await response.json();\r\n      if (resData.data) {\r\n        const bulk = resData.data.bulkProperties;\r\n        const sp = resData.data.stateProperties;\r\n        const zip = resData.data.zipProperties;\r\n        added = (bulk && bulk.length) || 0;\r\n        // await sleep(5000);\r\n        if (socket) {\r\n          socket.emit(\"property:add\", {\r\n            bulkproperties: bulk,\r\n            stateproperties: sp,\r\n            zipproperties: zip,\r\n          });\r\n        }\r\n\r\n        dispatch({\r\n          type: events.ADD_BULK_PROPERTIES,\r\n          data: bulk.reverse(),\r\n        });\r\n\r\n        dispatch({\r\n          type: events.ADD_MAP_PROPERTIES,\r\n          data: bulk,\r\n        });\r\n\r\n        dispatch({\r\n          type: events.STATE_PROPERTIES,\r\n          data: sp,\r\n        });\r\n\r\n        dispatch({\r\n          type: events.ZIP_PROPERTIES,\r\n          data: zip,\r\n        });\r\n      }\r\n\r\n      return { added, notfound: address.length - added };\r\n    } catch (err) {\r\n      if (err.message === \"OWNER-NOT-FOUND\") {\r\n        throw new Error(err.message);\r\n      }\r\n      console.log(\"Bulk add error\", err.message);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nconst getPropertyRecords = async (data) => {\r\n  try {\r\n    const url = `${PROPERTY_API}/property`;\r\n    const response = await fetch(url, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Token: \"AW9054ty6erfgk321\",\r\n      },\r\n      body: JSON.stringify(data),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errRes = await response.json();\r\n      let message = \"Something went wrong!\";\r\n      if (errRes && errRes.error) {\r\n        message = errRes.error;\r\n      }\r\n      throw new Error(message);\r\n    }\r\n\r\n    const resData = await response.json();\r\n    return resData.data;\r\n  } catch (err) {\r\n    console.log(\"getPropertyRecords\", err.message);\r\n    return null;\r\n  }\r\n};\r\n\r\nconst parseAddress = (ff) => {\r\n  if (!ff) {\r\n    return {\r\n      address1: \"\",\r\n      address2: \"\",\r\n      city: \"\",\r\n      state: \"\",\r\n      zip: \"\",\r\n      country: \"\",\r\n    };\r\n  }\r\n  ff = ff.split(\",\");\r\n\r\n  if (ff.length === 0) {\r\n    return {\r\n      address1: \"\",\r\n      address2: \"\",\r\n      city: \"\",\r\n      state: \"\",\r\n      zip: \"\",\r\n      country: \"\",\r\n    };\r\n  }\r\n  let address1 = \"\";\r\n  let address2 = \"\";\r\n  let city = \"\";\r\n  let state = \"\";\r\n  let zip = \"\";\r\n  let country = \"\";\r\n\r\n  if (ff.length === 1) {\r\n    ff = ff[0].split(\" \");\r\n    if (ff[ff.length - 1].length === 5) {\r\n      zip = ff[ff.length - 1];\r\n      state = ff[ff.length - 2];\r\n      city = ff[ff.length - 3];\r\n      address1 = ff.join().replace(zip, \"\");\r\n      address1 = address1.replace(state, \"\");\r\n      address1 = address1.replace(city, \"\");\r\n      ff = address1 + \", \" + city + \", \" + state + \" \" + zip;\r\n      ff = ff.split(\",\");\r\n    }\r\n  }\r\n\r\n  let first = ff[0].trim();\r\n  let last = ff[ff.length - 1].trim();\r\n\r\n  let containsZip = /\\d/.test(last);\r\n\r\n  country = \"\";\r\n  city = ff[ff.length - 3].trim();\r\n  if (containsZip) {\r\n    last = last.trim().split(\" \");\r\n    city = ff[ff.length - 2].trim();\r\n  } else {\r\n    country = last;\r\n    last = ff[ff.length - 2].trim();\r\n    last = last.split(\" \");\r\n  }\r\n\r\n  address1 = first;\r\n  address2 = city !== ff[1].trim() ? ff[1].trim() : \"\";\r\n  if (address2 !== \"\") {\r\n    city = ff[2].trim();\r\n  }\r\n  state = last[0].trim();\r\n  zip = last[1].trim();\r\n  return { address1, address2, city, state, zip, country };\r\n};\r\n\r\nexport const getPropertyOwner = () => {\r\n  return async (dispatch, getState) => {\r\n    const { city, zipcode, state, street, unitno } =\r\n      getState().properties.lastFetchedAddress;\r\n    const ff =\r\n      unitno + \" \" + street + \", \" + city + \", \" + state + \" \" + zipcode;\r\n    const propertyRecords = await getPropertyRecords({ address: [ff] });\r\n    if (propertyRecords && propertyRecords.length > 0) {\r\n      const property = propertyRecords[0];\r\n      let sqft = 0;\r\n      let acre = 0;\r\n      let area =\r\n        property.parcel && property.parcel[\"Area\"]\r\n          ? property.parcel[\"Area\"]\r\n          : \"0\";\r\n      if (area !== \"0\") {\r\n        area = area.split(\" \", 1);\r\n        area = area && area.length > 0 ? area[0] : \"0\";\r\n        area = area.replace(/,/g, \"\");\r\n        area = parseFloat(area).toFixed(2);\r\n        sqft = area;\r\n        acre = sqft > 0 ? (sqft / 43560).toFixed(2) : 0;\r\n      } else {\r\n        acre =\r\n          property.parcel && property.parcel[\"Area Lot (acres)\"]\r\n            ? property.parcel[\"Area Lot (acres)\"]\r\n            : \"0\";\r\n        acre = parseFloat(acre).toFixed(2);\r\n        sqft =\r\n          property.structure && property.structure[\"Area Lot (sf)\"]\r\n            ? property.structure[\"Area Lot (sf)\"]\r\n            : \"0\";\r\n\r\n        sqft = parseFloat(sqft).toFixed(2);\r\n      }\r\n\r\n      const ev =\r\n        property.valuation && property.valuation.length > 0\r\n          ? property.valuation[0][\"Value\"]\r\n          : \"0\";\r\n\r\n      const lastFetchedOwner = {\r\n        name: property.owner.Name,\r\n        address: property.owner.Address,\r\n        propertyaddress: property.parcel.Address,\r\n        commercial:\r\n          property.parcel &&\r\n          property.parcel[\"Land Use Category\"] &&\r\n          !property.parcel[\"Land Use Category\"].includes(\"Residential\"),\r\n        phone: null,\r\n        email: null,\r\n        gender: null,\r\n        age: null,\r\n        dob: null,\r\n        coords: property.coords,\r\n        attributes: property,\r\n        yearbuilt:\r\n          property.structure && property.structure[\"Year\"]\r\n            ? property.structure[\"Year\"]\r\n            : \"-\",\r\n        bed:\r\n          property.structure && property.structure[\"Bedrooms\"]\r\n            ? property.structure[\"Bedrooms\"]\r\n            : \"0\",\r\n        bath:\r\n          property.structure && property.structure[\"Bathrooms\"]\r\n            ? property.structure[\"Bathrooms\"]\r\n            : \"0\",\r\n        floor:\r\n          property.structure && property.structure[\"Stories\"]\r\n            ? property.structure[\"Stories\"]\r\n            : \"-\",\r\n        sqft,\r\n        acre,\r\n        ev,\r\n        apn: \"-\",\r\n      };\r\n      dispatch({\r\n        type: events.GET_PROPERTY_OWNER,\r\n        lastFetchedOwner,\r\n      });\r\n      return;\r\n    } else {\r\n      // TODO insert into owner-not-found collection\r\n\r\n      // const lastFetchedOwner = {\r\n      //   // firstname: \"OWNER-NOT\",\r\n      //   // middlename: \"\",\r\n      //   // lastname: \"-FOUND\",\r\n      //   name: \"OWNER-NOT-FOUND\",\r\n      //   address: \"\",\r\n      //   propertyaddress: \"\",\r\n      //   commercial: true,\r\n      //   company: false,\r\n      //   phone: \"0000000000\",\r\n      //   email: \"owner-not-found@shadow.properties\",\r\n      //   gender: \"NA\",\r\n      //   age: \"NA\",\r\n      //   dob: \"NA\",\r\n      //   attributes: null,\r\n      //   yearbuilt: \"-\",\r\n      //   bed: \"0\",\r\n      //   bath: \"0\",\r\n      //   floor: \"0\",\r\n      //   sqft: \"0\",\r\n      //   acre: \"0\",\r\n      //   ev: \"0\",\r\n      //   apn: \"-\",\r\n      // };\r\n\r\n      // dispatch({\r\n      //   type: events.GET_PROPERTY_OWNER,\r\n      //   lastFetchedOwner,\r\n      // });\r\n\r\n      throw new Error(\"OWNER-NOT-FOUND\");\r\n    }\r\n  };\r\n};\r\n\r\nexport const doSmartSearch = (_id) => {\r\n  return async (dispatch, getState) => {\r\n    try {\r\n      const { token, price, freetrial, sub } = getUser();\r\n      const { fetchedProperty: property, availableProperties } =\r\n        getState().properties;\r\n      const ok = property._id === _id;\r\n      if (!ok) {\r\n        throw new Error(\"Property not found for smartsearch.\");\r\n      }\r\n      if (property && !property.owneraddress) {\r\n        throw new Error(\"Owner address not found for smartsearch.\");\r\n      }\r\n      const ff = property.owneraddress;\r\n      const emaildefault = property.emails.length > 0 ? false : true;\r\n      const phonedefault = property.phones.length > 0 ? false : true;\r\n\r\n      const ssprice = price.smartsearch || freetrial.smartsearch || 0;\r\n\r\n      if (moment(sub.end).utc().isBefore(moment().utc()) && ssprice === 0) {\r\n        throw new Error(\r\n          \"Cannot do smartsearch, subscription details not found.\"\r\n        );\r\n      }\r\n      \r\n      const campaign = property.campaign ? property.campaign : null;\r\n      const response = await fetch(`${API_URL}/properties/smartsearch/${_id}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          \"Content-Type\": \"application/json\",\r\n          Authorization: \"Bearer \" + token,\r\n        },\r\n        body: JSON.stringify({\r\n          ff,\r\n          emaildefault,\r\n          phonedefault,\r\n          campaign,\r\n          price: ssprice,\r\n          tid: property.tid.toString(),\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const err = await response.json();\r\n        let msg = \"Something went wrong!\";\r\n        if (err.error) {\r\n          msg = err.error;\r\n        }\r\n        throw new Error(msg);\r\n      }\r\n\r\n      const resData = await response.json();\r\n      if (resData.data) {\r\n        refreshProperty(dispatch, availableProperties, resData.data);\r\n      }\r\n      return resData.data;\r\n    } catch (err) {\r\n      // send to custom analytics server\r\n      console.log(\"Error \", err);\r\n      throw err;\r\n    }\r\n  };\r\n};\r\n\r\nexport const getStates = () => {\r\n  const states = {\r\n    AL: \"Alabama\",\r\n    AK: \"Alaska\",\r\n    AS: \"American Samoa\",\r\n    AZ: \"Arizona\",\r\n    AR: \"Arkansas\",\r\n    CA: \"California\",\r\n    CO: \"Colorado\",\r\n    CT: \"Connecticut\",\r\n    DE: \"Delaware\",\r\n    DC: \"District Of Columbia\",\r\n    FM: \"Federated States Of Micronesia\",\r\n    FL: \"Florida\",\r\n    GA: \"Georgia\",\r\n    GU: \"Guam\",\r\n    HI: \"Hawaii\",\r\n    ID: \"Idaho\",\r\n    IL: \"Illinois\",\r\n    IN: \"Indiana\",\r\n    IA: \"Iowa\",\r\n    KS: \"Kansas\",\r\n    KY: \"Kentucky\",\r\n    LA: \"Louisiana\",\r\n    ME: \"Maine\",\r\n    MH: \"Marshall Islands\",\r\n    MD: \"Maryland\",\r\n    MA: \"Massachusetts\",\r\n    MI: \"Michigan\",\r\n    MN: \"Minnesota\",\r\n    MS: \"Mississippi\",\r\n    MO: \"Missouri\",\r\n    MT: \"Montana\",\r\n    NE: \"Nebraska\",\r\n    NV: \"Nevada\",\r\n    NH: \"New Hampshire\",\r\n    NJ: \"New Jersey\",\r\n    NM: \"New Mexico\",\r\n    NY: \"New York\",\r\n    NC: \"North Carolina\",\r\n    ND: \"North Dakota\",\r\n    MP: \"Northern Mariana Islands\",\r\n    OH: \"Ohio\",\r\n    OK: \"Oklahoma\",\r\n    OR: \"Oregon\",\r\n    PW: \"Palau\",\r\n    PA: \"Pennsylvania\",\r\n    PR: \"Puerto Rico\",\r\n    RI: \"Rhode Island\",\r\n    SC: \"South Carolina\",\r\n    SD: \"South Dakota\",\r\n    TN: \"Tennessee\",\r\n    TX: \"Texas\",\r\n    UT: \"Utah\",\r\n    VT: \"Vermont\",\r\n    VI: \"Virgin Islands\",\r\n    VA: \"Virginia\",\r\n    WA: \"Washington\",\r\n    WV: \"West Virginia\",\r\n    WI: \"Wisconsin\",\r\n    WY: \"Wyoming\",\r\n  };\r\n  return _.invert(states);\r\n};\r\n\r\nconst rGeoCode = async (data) => {\r\n  try {\r\n    // console.log(\"DATA\", data.length);\r\n    const result = await fetch(`${GEO_API}/reverse`, {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/json\",\r\n        Token: \"AW9054ty6erfgk321\",\r\n      },\r\n      body: JSON.stringify({ points: data, full: true }),\r\n    });\r\n\r\n    const response = await result.json();\r\n    if (response.data) {\r\n      return response.data;\r\n    } else {\r\n      return null;\r\n    }\r\n  } catch (err) {\r\n    console.log(\"rGeoCode error\", err.message);\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const getPropertyAddress = (coord) => {\r\n  return async (dispatch) => {\r\n    try {\r\n      const response = await rGeoCode([coord]);\r\n      if (!response) {\r\n        throw new Error(\"somthing went wrong\");\r\n      }\r\n\r\n      if (response && !response[0]) {\r\n        throw new Error(\"somthing went wrong\");\r\n      }\r\n      const address = response[0];\r\n\r\n      const components = address.address_components;\r\n\r\n      const ctry = components.find((f) => f.types.includes(\"country\"));\r\n\r\n      let country = \"\";\r\n      if (ctry) {\r\n        country = ctry.short_name;\r\n      }\r\n\r\n      if (ctry && country !== \"US\") {\r\n        throw new Error(\"This feature is unavailable in the selected country\");\r\n      }\r\n\r\n      const postal_code = components.find((f) =>\r\n        f.types.includes(\"postal_code\")\r\n      );\r\n\r\n      let zipcode = \"\";\r\n      if (postal_code) {\r\n        zipcode = postal_code.short_name;\r\n      }\r\n\r\n      const street_number = components.find((f) =>\r\n        f.types.includes(\"street_number\")\r\n      );\r\n\r\n      if (!street_number || !postal_code) {\r\n        throw new Error(\r\n          \"Street number or Zip code not found in the selected location\"\r\n        );\r\n      }\r\n\r\n      let unitno = \"\";\r\n      if (street_number) {\r\n        unitno = street_number.short_name;\r\n      }\r\n\r\n      const route = components.find((f) => f.types.includes(\"route\"));\r\n\r\n      let street = \"\";\r\n      if (route) {\r\n        street = route.short_name;\r\n      }\r\n\r\n      const city = components.find(\r\n        (f) => f.types.includes(\"locality\") || f.types.includes(\"sublocality\")\r\n      ).short_name;\r\n\r\n      const state = components.find((f) =>\r\n        f.types.includes(\"administrative_area_level_1\")\r\n      ).short_name;\r\n\r\n      const fulladdress = address.formatted_address;\r\n      const { lat: latitude, lng: longitude } = address.geometry.location;\r\n\r\n      const lastFetchedAddress = {\r\n        address: fulladdress,\r\n        unitno,\r\n        street,\r\n        city,\r\n        state,\r\n        country,\r\n        zipcode,\r\n        location: { latitude, longitude },\r\n      };\r\n\r\n      dispatch({\r\n        type: events.GET_PROPERTY_ADDRESS,\r\n        lastFetchedAddress,\r\n      });\r\n    } catch (err) {\r\n      // console.log(err);\r\n      throw new Error(err.message);\r\n    }\r\n  };\r\n};\r\n\r\nfunction sleep(ms) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nexport const uploadPropertyPicture = (picture, setProgress) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { lastAddedProperty: property } = getState().properties;\r\n    const formData = new FormData();\r\n    formData.append(\"_id\", property._id);\r\n    formData.append(\"default\", true);\r\n    formData.append(\"picture\", {\r\n      type: \"image/jpg\",\r\n      uri: picture,\r\n      name: \"shadow_properties_\" + property._id + \".jpg\",\r\n    });\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(\"POST\", `${API_URL}/properties/upload/picture`, true);\r\n    xhr.addEventListener(\r\n      \"progress\",\r\n      function (e) {\r\n        // // console.log(e)\r\n        // var done = e.position || e.loaded,\r\n        //   total = e.totalSize || e.total;\r\n        // dispatch({\r\n        //   type: events.SET_PROGRESS,\r\n        //   progress: Math.floor((done / total) * 1000) / 10,\r\n        // });\r\n        // console.log(\r\n        //   \"xhr progress: \" + Math.floor((done / total) * 1000) / 10 + \"%\"\r\n        // );\r\n      },\r\n      false\r\n    );\r\n    if (xhr.upload) {\r\n      xhr.upload.onprogress = function (e) {\r\n        // console.log(\"onprogress\", e)\r\n        var done = e.loaded,\r\n          total = e.total;\r\n        dispatch({\r\n          type: events.SET_PROGRESS,\r\n          progress: Math.floor((done / total) * 1000) / 10,\r\n        });\r\n        setProgress(Math.floor((done / total) * 1000) / 10);\r\n        // console.log(\r\n        //   \"xhr.upload progress: \" +\r\n        //     done +\r\n        //     \" / \" +\r\n        //     total +\r\n        //     \" = \" +\r\n        //     Math.floor((done / total) * 1000) / 10 +\r\n        //     \"%\"\r\n        // );\r\n      };\r\n    }\r\n    xhr.setRequestHeader(\"Content-Type\", \"multipart/form-data\");\r\n    xhr.setRequestHeader(\"Authorization\", `Bearer ${token}`);\r\n    xhr.onreadystatechange = async function () {\r\n      if (this.readyState === 4 && this.status === 200) {\r\n        const availableProperties = getState().properties.availableProperties;\r\n        const resData = JSON.parse(this.responseText);\r\n        refreshProperty(dispatch, availableProperties, resData.data);\r\n        console.log(\"Image uploaded successfully!\");\r\n      } else {\r\n        // console.log(this.responseText);\r\n      }\r\n    };\r\n    xhr.send(formData);\r\n  };\r\n};\r\n\r\nexport const uploadBulkPropertyPicture = (picture, id) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const { lastAddedProperty: property, availableProperties } =\r\n      getState().properties;\r\n    const formData = new FormData();\r\n    formData.append(\"_id\", id);\r\n    formData.append(\"default\", true);\r\n    formData.append(\"picture\", {\r\n      type: \"image/jpg\",\r\n      uri: picture,\r\n      name: \"shadow_properties_\" + id + \".jpg\",\r\n    });\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(\"POST\", `${API_URL}/properties/upload/picture`, true);\r\n    xhr.addEventListener(\r\n      \"progress\",\r\n      function (e) {\r\n        var done = e.position || e.loaded,\r\n          total = e.totalSize || e.total;\r\n        // dispatch({\r\n        //   type: SET_PROGRESS,\r\n        //   progress: Math.floor((done / total) * 1000) / 10,\r\n        // });\r\n        console.log(\r\n          \"xhr progress: \" + Math.floor((done / total) * 1000) / 10 + \"%\"\r\n        );\r\n      },\r\n      false\r\n    );\r\n    if (xhr.upload) {\r\n      xhr.upload.onprogress = function (e) {\r\n        // var done = e.position || e.loaded,\r\n        //   total = e.totalSize || e.total;\r\n        // setProgress(Math.floor((done / total) * 1000) / 10);\r\n        // console.log(\r\n        //   'xhr.upload progress: ' +\r\n        //     done +\r\n        //     ' / ' +\r\n        //     total +\r\n        //     ' = ' +\r\n        //     Math.floor((done / total) * 1000) / 10 +\r\n        //     '%'\r\n        // );\r\n      };\r\n    }\r\n    xhr.setRequestHeader(\"Content-Type\", \"multipart/form-data\");\r\n    xhr.setRequestHeader(\"Authorization\", `Bearer ${token}`);\r\n    xhr.onreadystatechange = async function () {\r\n      if (this.readyState === 4 && this.status === 200) {\r\n        await sleep(100);\r\n        let properties = [];\r\n        if (availableProperties && availableProperties.length > 0) {\r\n          const x = availableProperties.find((p) => p._id === property._id);\r\n          if (x) {\r\n            properties = availableProperties.map((p) => {\r\n              if (p._id === property._id) {\r\n                p = property;\r\n              }\r\n              return p;\r\n            });\r\n          } else {\r\n            properties = [property, ...availableProperties];\r\n          }\r\n        } else {\r\n          properties = [property];\r\n        }\r\n\r\n        dispatch({\r\n          type: events.SET_PROPERTIES,\r\n          properties,\r\n        });\r\n      } else {\r\n        // console.log(this.responseText);\r\n      }\r\n    };\r\n    xhr.send(formData);\r\n  };\r\n};\r\n\r\nexport const changePropertyPicture = (picture, _id, setProgress, cb) => {\r\n  return async (dispatch, getState) => {\r\n    const { token } = getUser();\r\n    const formData = new FormData();\r\n\r\n    formData.append(\"_id\", _id);\r\n    formData.append(\"default\", false);\r\n    formData.append(\"picture\", {\r\n      type: \"image/jpg\",\r\n      uri: picture,\r\n      name: \"shadow_properties_\" + _id + \".jpg\",\r\n    });\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(\"POST\", `${API_URL}/properties/upload/picture`, true);\r\n    xhr.addEventListener(\r\n      \"progress\",\r\n      function (e) {\r\n        var done = e.position || e.loaded,\r\n          total = e.totalSize || e.total;\r\n\r\n        console.log(\r\n          \"xhr progress: \" + Math.floor((done / total) * 1000) / 10 + \"%\"\r\n        );\r\n      },\r\n      false\r\n    );\r\n    if (xhr.upload) {\r\n      xhr.upload.onprogress = function (e) {\r\n        var done = e.position || e.loaded,\r\n          total = e.totalSize || e.total;\r\n        setProgress(Math.floor((done / total) * 1000) / 10);\r\n      };\r\n    }\r\n    xhr.setRequestHeader(\"Content-Type\", \"multipart/form-data\");\r\n    xhr.setRequestHeader(\"Authorization\", \"Bearer \" + token);\r\n    xhr.onreadystatechange = async function () {\r\n      if (this.readyState === 4 && this.status === 200) {\r\n        //console.log(this.responseText);\r\n        //this.responseText;\r\n        // setStatus(this.responseText);\r\n        const resData = JSON.parse(this.responseText);\r\n        const availableProperties = getState().properties.availableProperties;\r\n        refreshProperty(dispatch, availableProperties, resData.data);\r\n        cb(\"Image uploaded successfully!\");\r\n      } else {\r\n        console.log(\"Image Upload Failed\");\r\n      }\r\n    };\r\n    xhr.send(formData);\r\n  };\r\n};\r\n"],"names":["primary","accent","getUser","localStorage","getItem","JSON","parse","filtersTotal","storedFilters","total","filters","filter","date","from","to","length","fetchProperties","page","limit","search","dispatch","getState","token","isFiltered","storedFilter","sort","_id","moment","startOf","toISOString","endOf","tags","status","bath","map","b","parseInt","bed","acre","a","sqft","year","f","toString","ev","replace","console","log","order","sortBy","body","stringify","skip","fields","name","propertyaddress","owneraddress","coords","floor","yearbuilt","apn","tid","mid","pic","created","modified","fetch","API_URL","method","headers","Authorization","response","ok","json","Error","resData","type","events","properties","data","count","fetchStatus","default","fetchTags","e","msg","error","fetchPropertyById","setDefaultImage","socket","errorResData","message","emit","availableProperties","refreshProperty","updatePropertyStatus","errRes","updatePropertyTag","savePropertyTag","updatedProperty","refreshedProperties","item","i","Object","keys","includes","savePropertyNote","saveMailingAddress","url","err","savePhoneNumbers","saveEmails","property","fetchedProperty","campaign","updatePostCardName","updateOutreachCampaignSettings","errorRes","stopPropertiesCampaign","manualcampaign","success","removeProperties","moveProperties","setPropertiesCampaign","addBulkProperties","address","pipeline","list","autosmartsearch","profile","auth","added","price","plan","smartsearch","freetrial","route_id","global","bulk","bulkProperties","sp","stateProperties","zip","zipProperties","bulkproperties","stateproperties","zipproperties","reverse","notfound","doSmartSearch","sub","ff","emaildefault","emails","phonedefault","phones","ssprice","end","utc","isBefore"],"sourceRoot":""}