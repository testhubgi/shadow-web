{"version":3,"file":"static/js/9929.0bc2eb90.chunk.js","mappings":"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","sources":["../node_modules/native-base/lib/module/components/composites/Backdrop/index.tsx","../node_modules/native-base/node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/FocusScope.tsx","../node_modules/native-base/node_modules/@react-aria/focus/dist/packages/@react-aria/focus/src/useFocusable.tsx","../node_modules/native-base/lib/module/components/composites/Menu/useMenu.tsx","../node_modules/native-base/lib/module/components/composites/Menu/MenuContext.ts","../node_modules/native-base/lib/module/components/composites/Menu/Menu.tsx","../node_modules/native-base/lib/module/components/composites/Menu/MenuGroup.tsx","../node_modules/native-base/lib/module/components/composites/Menu/MenuItem.tsx","../node_modules/native-base/lib/module/components/composites/Menu/MenuOptionGroup.tsx","../node_modules/native-base/lib/module/components/composites/Menu/MenuItemOption.tsx","../node_modules/native-base/lib/module/components/composites/Menu/index.tsx","../node_modules/native-base/lib/module/components/composites/Popper/Popper.tsx","../node_modules/native-base/lib/module/components/primitives/Hidden/index.tsx","../node_modules/native-base/lib/module/components/primitives/Icon/Icons/Check.tsx","../node_modules/native-base/lib/module/components/primitives/Icon/Icons/questionIconPath.tsx","../node_modules/native-base/lib/module/components/primitives/Icon/SVGIcon.tsx","../node_modules/native-base/lib/module/components/primitives/Icon/createIcon.tsx","../node_modules/native-base/lib/module/components/primitives/Icon/nbSvg.web.tsx","../node_modules/native-base/lib/module/hooks/useBreakpointValue.ts","../node_modules/native-base/lib/module/hooks/useControllableProp.ts","../node_modules/native-base/lib/module/hooks/useToken.ts"],"sourcesContent":["import React, { memo } from 'react';\nimport { Pressable, IPressableProps } from '../../primitives/Pressable';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\n\nconst Backdrop = (props: IPressableProps) => {\n  //TODO: refactor for responsive prop\n  if (useHasResponsiveProps(props)) {\n    return null;\n  }\n  return (\n    <Pressable\n      _web={{\n        //@ts-ignore\n        cursor: 'default',\n      }}\n      position=\"absolute\"\n      top={0}\n      bottom={0}\n      left={0}\n      right={0}\n      accessible={false}\n      importantForAccessibility=\"no\"\n      bg={props.bg || 'rgb(0, 0, 0)'}\n      opacity={0.3}\n      {...props}\n    />\n  );\n};\n\nexport default memo(Backdrop);\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusSafely} from './focusSafely';\nimport React, {ReactNode, RefObject, useContext, useEffect, useRef} from 'react';\nimport {useLayoutEffect} from '@react-aria/utils';\n\n// import {FocusScope, useFocusScope} from 'react-events/focus-scope';\n// export {FocusScope};\n\ninterface FocusScopeProps {\n  /** The contents of the focus scope. */\n  children: ReactNode,\n\n  /**\n   * Whether to contain focus inside the scope, so users cannot\n   * move focus outside, for example in a modal dialog.\n   */\n  contain?: boolean,\n\n  /**\n   * Whether to restore focus back to the element that was focused\n   * when the focus scope mounted, after the focus scope unmounts.\n   */\n  restoreFocus?: boolean,\n\n  /** Whether to auto focus the first focusable element in the focus scope on mount. */\n  autoFocus?: boolean\n}\n\ninterface FocusManagerOptions {\n  /** The element to start searching from. The currently focused element by default. */\n  from?: HTMLElement,\n  /** Whether to only include tabbable elements, or all focusable elements. */\n  tabbable?: boolean,\n  /** Whether focus should wrap around when it reaches the end of the scope. */\n  wrap?: boolean\n}\n\ninterface FocusManager {\n  /** Moves focus to the next focusable or tabbable element in the focus scope. */\n  focusNext(opts?: FocusManagerOptions): HTMLElement,\n  /** Moves focus to the previous focusable or tabbable element in the focus scope. */\n  focusPrevious(opts?: FocusManagerOptions): HTMLElement\n}\n\nconst FocusContext = React.createContext<FocusManager>(null);\n\nlet activeScope: RefObject<HTMLElement[]> = null;\nlet scopes: Set<RefObject<HTMLElement[]>> = new Set();\n\n// This is a hacky DOM-based implementation of a FocusScope until this RFC lands in React:\n// https://github.com/reactjs/rfcs/pull/109\n// For now, it relies on the DOM tree order rather than the React tree order, and is probably\n// less optimized for performance.\n\n/**\n * A FocusScope manages focus for its descendants. It supports containing focus inside\n * the scope, restoring focus to the previously focused element on unmount, and auto\n * focusing children on mount. It also acts as a container for a programmatic focus\n * management interface that can be used to move focus forward and back in response\n * to user events.\n */\nexport function FocusScope(props: FocusScopeProps) {\n  let {children, contain, restoreFocus, autoFocus} = props;\n  let startRef = useRef<HTMLSpanElement>();\n  let endRef = useRef<HTMLSpanElement>();\n  let scopeRef = useRef<HTMLElement[]>([]);\n\n  useLayoutEffect(() => {\n    // Find all rendered nodes between the sentinels and add them to the scope.\n    let node = startRef.current.nextSibling;\n    let nodes = [];\n    while (node && node !== endRef.current) {\n      nodes.push(node);\n      node = node.nextSibling;\n    }\n\n    scopeRef.current = nodes;\n    scopes.add(scopeRef);\n    return () => {\n      scopes.delete(scopeRef);\n    };\n  }, [children]);\n\n  useFocusContainment(scopeRef, contain);\n  useRestoreFocus(scopeRef, restoreFocus, contain);\n  useAutoFocus(scopeRef, autoFocus);\n\n  let focusManager = createFocusManager(scopeRef);\n\n  return (\n    <FocusContext.Provider value={focusManager}>\n      <span hidden ref={startRef} />\n      {children}\n      <span hidden ref={endRef} />\n    </FocusContext.Provider>\n  );\n}\n\n/**\n * Returns a FocusManager interface for the parent FocusScope.\n * A FocusManager can be used to programmatically move focus within\n * a FocusScope, e.g. in response to user events like keyboard navigation.\n */\nexport function useFocusManager(): FocusManager {\n  return useContext(FocusContext);\n}\n\nfunction createFocusManager(scopeRef: React.RefObject<HTMLElement[]>): FocusManager {\n  return {\n    focusNext(opts: FocusManagerOptions = {}) {\n      let node = opts.from || document.activeElement;\n      let focusable = getFocusableElementsInScope(scopeRef.current, opts);\n      let nextNode = focusable.find(n =>\n        !!(node.compareDocumentPosition(n) & (Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY))\n      );\n      if (!nextNode && opts.wrap) {\n        nextNode = focusable[0];\n      }\n      if (nextNode) {\n        nextNode.focus();\n      }\n      return nextNode;\n    },\n    focusPrevious(opts: FocusManagerOptions = {}) {\n      let node = opts.from || document.activeElement;\n      let focusable = getFocusableElementsInScope(scopeRef.current, opts).reverse();\n      let previousNode = focusable.find(n =>\n        !!(node.compareDocumentPosition(n) & (Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY))\n      );\n      if (!previousNode && opts.wrap) {\n        previousNode = focusable[0];\n      }\n      if (previousNode) {\n        previousNode.focus();\n      }\n      return previousNode;\n    }\n  };\n}\n\nconst focusableElements = [\n  'input:not([disabled]):not([type=hidden])',\n  'select:not([disabled])',\n  'textarea:not([disabled])',\n  'button:not([disabled])',\n  'a[href]',\n  'area[href]',\n  'summary',\n  'iframe',\n  'object',\n  'embed',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]'\n];\n\nconst FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(',') + ',[tabindex]';\n\nfocusableElements.push('[tabindex]:not([tabindex=\"-1\"])');\nconst TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([tabindex=\"-1\"]),');\n\nfunction getFocusableElementsInScope(scope: HTMLElement[], opts: FocusManagerOptions): HTMLElement[] {\n  let res = [];\n  let selector = opts.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  for (let node of scope) {\n    if (node.matches(selector)) {\n      res.push(node);\n    }\n    res.push(...Array.from(node.querySelectorAll(selector)));\n  }\n  return res;\n}\n\nfunction useFocusContainment(scopeRef: RefObject<HTMLElement[]>, contain: boolean) {\n  let focusedNode = useRef<HTMLElement>();\n\n  let raf = useRef(null);\n  useEffect(() => {\n    let scope = scopeRef.current;\n    if (!contain) {\n      return;\n    }\n\n    // Handle the Tab key to contain focus within the scope\n    let onKeyDown = (e) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n\n      let focusedElement = document.activeElement as HTMLElement;\n      if (!isElementInScope(focusedElement, scope)) {\n        return;\n      }\n\n      let elements = getFocusableElementsInScope(scope, {tabbable: true});\n      let position = elements.indexOf(focusedElement);\n      let lastPosition = elements.length - 1;\n      let nextElement = null;\n\n      if (e.shiftKey) {\n        if (position <= 0) {\n          nextElement = elements[lastPosition];\n        } else {\n          nextElement = elements[position - 1];\n        }\n      } else {\n        if (position === lastPosition) {\n          nextElement = elements[0];\n        } else {\n          nextElement = elements[position + 1];\n        }\n      }\n\n      e.preventDefault();\n      if (nextElement) {\n        focusElement(nextElement, true);\n      }\n    };\n\n    let onFocus = (e) => {\n      // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n      // restore focus to the previously focused node or the first tabbable element in the active scope.\n      let isInAnyScope = isElementInAnyScope(e.target, scopes);\n      if (!isInAnyScope) {\n        if (focusedNode.current) {\n          focusedNode.current.focus();\n        } else if (activeScope) {\n          focusFirstInScope(activeScope.current);\n        }\n      } else {\n        activeScope = scopeRef;\n        focusedNode.current = e.target;\n      }\n    };\n\n    let onBlur = (e) => {\n      // Firefox doesn't shift focus back to the Dialog properly without this\n      raf.current = requestAnimationFrame(() => {\n        // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n        let isInAnyScope = isElementInAnyScope(document.activeElement, scopes);\n\n        if (!isInAnyScope) {\n          activeScope = scopeRef;\n          focusedNode.current = e.target;\n          focusedNode.current.focus();\n        }\n      });\n    };\n\n    document.addEventListener('keydown', onKeyDown, false);\n    document.addEventListener('focusin', onFocus, false);\n    scope.forEach(element => element.addEventListener('focusin', onFocus, false));\n    scope.forEach(element => element.addEventListener('focusout', onBlur, false));\n    return () => {\n      document.removeEventListener('keydown', onKeyDown, false);\n      document.removeEventListener('focusin', onFocus, false);\n      scope.forEach(element => element.removeEventListener('focusin', onFocus, false));\n      scope.forEach(element => element.removeEventListener('focusout', onBlur, false));\n    };\n  }, [scopeRef, contain]);\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => cancelAnimationFrame(raf.current);\n  }, [raf]);\n}\n\nfunction isElementInAnyScope(element: Element, scopes: Set<RefObject<HTMLElement[]>>) {\n  for (let scope of scopes.values()) {\n    if (isElementInScope(element, scope.current)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isElementInScope(element: Element, scope: HTMLElement[]) {\n  return scope.some(node => node.contains(element));\n}\n\nfunction focusElement(element: HTMLElement | null, scroll = false) {\n  if (element != null && !scroll) {\n    try {\n      focusSafely(element);\n    } catch (err) {\n      // ignore\n    }\n  } else if (element != null) {\n    try {\n      element.focus();\n    } catch (err) {\n      // ignore\n    }\n  }\n}\n\nfunction focusFirstInScope(scope: HTMLElement[]) {\n  let elements = getFocusableElementsInScope(scope, {tabbable: true});\n  focusElement(elements[0]);\n}\n\nfunction useAutoFocus(scopeRef: RefObject<HTMLElement[]>, autoFocus: boolean) {\n  useEffect(() => {\n    if (autoFocus) {\n      activeScope = scopeRef;\n      if (!isElementInScope(document.activeElement, activeScope.current)) {\n        focusFirstInScope(scopeRef.current);\n      }\n    }\n  }, [scopeRef, autoFocus]);\n}\n\nfunction useRestoreFocus(scopeRef: RefObject<HTMLElement[]>, restoreFocus: boolean, contain: boolean) {\n  // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n  useLayoutEffect(() => {\n    let scope = scopeRef.current;\n    let nodeToRestore = document.activeElement as HTMLElement;\n\n    // Handle the Tab key so that tabbing out of the scope goes to the next element\n    // after the node that had focus when the scope mounted. This is important when\n    // using portals for overlays, so that focus goes to the expected element when\n    // tabbing out of the overlay.\n    let onKeyDown = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) {\n        return;\n      }\n\n      let focusedElement = document.activeElement as HTMLElement;\n      if (!isElementInScope(focusedElement, scope)) {\n        return;\n      }\n\n      // Create a DOM tree walker that matches all tabbable elements\n      let walker = getFocusableTreeWalker(document.body, {tabbable: true});\n\n      // Find the next tabbable element after the currently focused element\n      walker.currentNode = focusedElement;\n      let nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as HTMLElement;\n\n      // If there is no next element, or it is outside the current scope, move focus to the\n      // next element after the node to restore to instead.\n      if ((!nextElement || !isElementInScope(nextElement, scope)) && nodeToRestore) {\n        walker.currentNode = nodeToRestore;\n\n        // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n        do {\n          nextElement = (e.shiftKey ? walker.previousNode() : walker.nextNode()) as HTMLElement;\n        } while (isElementInScope(nextElement, scope));\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (nextElement) {\n          nextElement.focus();\n        } else {\n          // If there is no next element, blur the focused element to move focus to the body.\n          focusedElement.blur();\n        }\n      }\n    };\n\n    if (!contain) {\n      document.addEventListener('keydown', onKeyDown, true);\n    }\n\n    return () => {\n      if (!contain) {\n        document.removeEventListener('keydown', onKeyDown, true);\n      }\n\n      if (restoreFocus && nodeToRestore && isElementInScope(document.activeElement, scope)) {\n        requestAnimationFrame(() => {\n          if (document.body.contains(nodeToRestore)) {\n            focusElement(nodeToRestore);\n          }\n        });\n      }\n    };\n  }, [scopeRef, restoreFocus, contain]);\n}\n\n/**\n * Create a [TreeWalker]{@link https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker}\n * that matches all focusable/tabbable elements.\n */\nexport function getFocusableTreeWalker(root: HTMLElement, opts?: FocusManagerOptions) {\n  let selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;\n  let walker = document.createTreeWalker(\n    root,\n    NodeFilter.SHOW_ELEMENT,\n    {\n      acceptNode(node) {\n        // Skip nodes inside the starting node.\n        if (opts?.from?.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if ((node as HTMLElement).matches(selector)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n    },\n    false\n  );\n\n  if (opts?.from) {\n    walker.currentNode = opts.from;\n  }\n\n  return walker;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableDOMProps, FocusableProps} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport React, {HTMLAttributes, MutableRefObject, ReactNode, RefObject, useContext, useEffect} from 'react';\nimport {useFocus, useKeyboard} from '@react-aria/interactions';\n\ninterface FocusableOptions extends FocusableProps, FocusableDOMProps {\n  /** Whether focus should be disabled. */\n  isDisabled?: boolean\n}\n\ninterface FocusableProviderProps extends HTMLAttributes<HTMLElement> {\n  /** The child element to provide DOM props to. */\n  children?: ReactNode\n}\n\ninterface FocusableContextValue extends FocusableProviderProps {\n  ref?: MutableRefObject<HTMLElement>\n}\n\nlet FocusableContext = React.createContext<FocusableContextValue>(null);\n\nfunction useFocusableContext(ref: RefObject<HTMLElement>): FocusableContextValue {\n  let context = useContext(FocusableContext) || {};\n\n  useEffect(() => {\n    if (context && context.ref) {\n      context.ref.current = ref.current;\n      return () => {\n        context.ref.current = null;\n      };\n    }\n  }, [context, ref]);\n\n  return context;\n}\n\n/**\n * Provides DOM props to the nearest focusable child.\n */\nfunction FocusableProvider(props: FocusableProviderProps, ref: RefObject<HTMLElement>) {\n  let {children, ...otherProps} = props;\n  let context = {\n    ...otherProps,\n    ref\n  };\n\n  return (\n    <FocusableContext.Provider value={context}>\n      {children}\n    </FocusableContext.Provider>\n  );\n}\n\nlet _FocusableProvider = React.forwardRef(FocusableProvider);\nexport {_FocusableProvider as FocusableProvider};\n\n/**\n * Used to make an element focusable and capable of auto focus.\n */\nexport function useFocusable(props: FocusableOptions, domRef: RefObject<HTMLElement>) {\n  let {focusProps} = useFocus(props);\n  let {keyboardProps} = useKeyboard(props);\n  let interactions = mergeProps(focusProps, keyboardProps);\n  let domProps = useFocusableContext(domRef);\n  let interactionProps = props.isDisabled ? {} : domProps;\n\n  useEffect(() => {\n    if (props.autoFocus && domRef.current) {\n      domRef.current.focus();\n    }\n  }, [props.autoFocus, domRef]);\n\n  return {\n    focusableProps: mergeProps(\n      {\n        ...interactions,\n        tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined\n      },\n      interactionProps\n    )\n  };\n}\n","import React from 'react';\nimport { useFocusManager } from '@react-aria/focus';\nimport { useId } from '@react-native-aria/utils';\nimport { AccessibilityRole, Platform } from 'react-native';\nimport { ResponsiveQueryContext } from '../../../utils/useResponsiveQuery/ResponsiveQueryProvider';\nimport { uniqueId } from 'lodash';\n\ntype IMenuTriggerProps = {\n  handleOpen: () => void;\n  isOpen: boolean;\n};\n\nexport const useMenuTrigger = ({ handleOpen, isOpen }: IMenuTriggerProps) => {\n  let menuTriggerId = uniqueId();\n\n  // let id = uniqueId();\n  const responsiveQueryContext = React.useContext(ResponsiveQueryContext);\n  const disableCSSMediaQueries = responsiveQueryContext.disableCSSMediaQueries;\n\n  if (!disableCSSMediaQueries) {\n    // This if statement technically breaks the rules of hooks, but is safe\n    // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    menuTriggerId = useId();\n  }\n  return {\n    'onKeyDownCapture': (event: KeyboardEvent) => {\n      if ([' ', 'Enter', 'ArrowUp', 'ArrowDown'].includes(event.key)) {\n        event.preventDefault();\n        handleOpen();\n      }\n    },\n    'aria-haspopup': 'menu',\n    'aria-expanded': isOpen ? true : undefined,\n    'nativeID': menuTriggerId,\n  };\n};\n\nexport const useMenu = () => {\n  const focusManager = useFocusManager();\n  const onKeyDown = (e: KeyboardEvent) => {\n    switch (e.key) {\n      case 'ArrowDown': {\n        e.preventDefault();\n        focusManager.focusNext({ wrap: true });\n        break;\n      }\n      case 'ArrowUp': {\n        e.preventDefault();\n        focusManager.focusPrevious({ wrap: true });\n        break;\n      }\n    }\n  };\n\n  return {\n    onKeyDown,\n    accessibilityRole: 'menu' as AccessibilityRole,\n  };\n};\n\nexport const useMenuItem = ({\n  textValue,\n  ref,\n}: {\n  textValue: string;\n  ref: any;\n}) => {\n  return {\n    accessibilityRole: 'menuitem' as AccessibilityRole,\n    dataSet: {\n      nativebaseMenuItem: textValue,\n    },\n    onHoverIn: () => {\n      if (ref.current && Platform.OS === 'web') ref.current.focus();\n    },\n  };\n};\n\nexport const useMenuOptionItem = ({\n  isChecked,\n  type,\n}: {\n  isChecked: boolean;\n  type: 'checkbox' | 'radio';\n}) => {\n  return {\n    accessibilityRole: ('menuitem' +\n      (Platform.OS === 'web' ? type : '')) as AccessibilityRole,\n    accessibilityState: {\n      checked: isChecked,\n    },\n    accessibilityChecked: isChecked,\n  };\n};\n\nconst ITEM_ATTR = 'data-nativebase-menu-item';\nconst getValue = (element: Element) => element.getAttribute(ITEM_ATTR) ?? '';\n\nexport const useMenuTypeahead = (props: any): any => {\n  return {\n    onKeyDown(event: KeyboardEvent) {\n      if (props.onKeyDown) {\n        props.onKeyDown(event);\n      }\n\n      if (\n        event.key.length === 1 &&\n        !(event.ctrlKey || event.altKey || event.metaKey)\n      ) {\n        const container = event.currentTarget as HTMLElement;\n        const values = Array.from(\n          container.querySelectorAll(`[${ITEM_ATTR}]`)\n        ).map(getValue);\n\n        const searchKey = event.key;\n\n        const foundValue = values.find((value) =>\n          value.toLowerCase().startsWith(searchKey)\n        );\n        const newItem = container.querySelector(\n          `[${ITEM_ATTR}=\"${foundValue}\"]`\n        );\n\n        if (newItem) {\n          /**\n           * Imperative focus during keydown is risky so we prevent React's batching updates\n           * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n           */\n          setTimeout(() => (newItem as HTMLElement).focus());\n        }\n      }\n    },\n  };\n};\n","import React from 'react';\nexport const MenuContext = React.createContext({\n  closeOnSelect: true,\n  onClose: () => {},\n});\n","import React, { memo, forwardRef } from 'react';\nimport type { IMenuProps } from './types';\nimport Box from '../../primitives/Box';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport { Popper } from '../Popper';\nimport { AccessibilityInfo, ScrollView } from 'react-native';\nimport { useControllableState } from '../../../hooks';\nimport { useMenuTrigger, useMenu, useMenuTypeahead } from './useMenu';\nimport Backdrop from '../Backdrop';\nimport { PresenceTransition } from '../Transitions';\nimport { FocusScope } from '@react-native-aria/focus';\nimport { MenuContext } from './MenuContext';\nimport { Overlay } from '../../primitives/Overlay';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\n\nconst Menu = (\n  {\n    trigger,\n    closeOnSelect = true,\n    children,\n    onOpen,\n    onClose,\n    isOpen: isOpenProp,\n    defaultIsOpen,\n    placement = 'bottom left',\n    ...props\n  }: IMenuProps,\n  ref?: any\n) => {\n  const triggerRef = React.useRef(null);\n  const [isOpen, setIsOpen] = useControllableState({\n    value: isOpenProp,\n    defaultValue: defaultIsOpen,\n    onChange: (value) => {\n      value ? onOpen && onOpen() : onClose && onClose();\n    },\n  });\n\n  const {\n    _overlay,\n    _presenceTransition,\n    _backdrop,\n    useRNModal,\n    ...resolvedProps\n  } = usePropsResolution('Menu', props);\n  const handleOpen = React.useCallback(() => {\n    setIsOpen(true);\n  }, [setIsOpen]);\n\n  const handleClose = React.useCallback(() => {\n    setIsOpen(false);\n  }, [setIsOpen]);\n\n  const triggerProps = useMenuTrigger({\n    handleOpen,\n    isOpen,\n  });\n\n  const updatedTrigger = () => {\n    return trigger(\n      {\n        ...triggerProps,\n        ref: triggerRef,\n        onPress: handleOpen,\n      },\n      { open: isOpen }\n    );\n  };\n\n  React.useEffect(() => {\n    if (isOpen) {\n      AccessibilityInfo.announceForAccessibility('Popup window');\n    }\n  }, [isOpen]);\n\n  //TODO: refactor for responsive prop\n  if (useHasResponsiveProps(resolvedProps)) {\n    return null;\n  }\n  return (\n    <>\n      {updatedTrigger()}\n      <Overlay\n        isOpen={isOpen}\n        onRequestClose={handleClose}\n        useRNModalOnAndroid\n        useRNModal={useRNModal}\n        {..._overlay}\n        unmountOnExit\n      >\n        <PresenceTransition visible={isOpen} {..._presenceTransition}>\n          <Popper\n            triggerRef={triggerRef}\n            onClose={handleClose}\n            placement={placement}\n            {...resolvedProps}\n          >\n            <Backdrop onPress={handleClose} {..._backdrop} />\n            <Popper.Content isOpen={isOpen}>\n              <MenuContext.Provider\n                value={{ closeOnSelect, onClose: handleClose }}\n              >\n                <FocusScope contain restoreFocus autoFocus>\n                  <MenuContent menuRef={ref} {...resolvedProps}>\n                    {children}\n                  </MenuContent>\n                </FocusScope>\n              </MenuContext.Provider>\n            </Popper.Content>\n          </Popper>\n        </PresenceTransition>\n      </Overlay>\n    </>\n  );\n};\n\nconst MenuContent = ({\n  menuRef,\n  children,\n  ...props\n}: Omit<IMenuProps, 'trigger'> & { menuRef: any }) => {\n  const menuProps = useMenu();\n  const typeaheadProps = useMenuTypeahead(menuProps);\n\n  return (\n    <Box {...props} {...menuProps} {...typeaheadProps} ref={menuRef}>\n      <ScrollView>{children}</ScrollView>\n    </Box>\n  );\n};\n\nexport default memo(forwardRef(Menu));\n","import React, { memo, forwardRef } from 'react';\nimport Text from '../../primitives/Text';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport Box from '../../primitives/Box';\nimport type { IMenuGroupProps } from './types';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\n\nconst MenuGroup = (\n  { title, children, ...props }: IMenuGroupProps,\n  ref: any\n) => {\n  const { _title, ...resolvedProps } = usePropsResolution('MenuGroup', props);\n\n  //TODO: refactor for responsive prop\n  if (useHasResponsiveProps({ ...props, title })) {\n    return null;\n  }\n\n  //TODO: Can be simplified\n  return (\n    <>\n      <Box {...resolvedProps} ref={ref}>\n        <Text {..._title}>{title}</Text>\n      </Box>\n      {children}\n    </>\n  );\n};\n\nexport default memo(forwardRef(MenuGroup));\n","import React, { forwardRef, memo } from 'react';\nimport Text from '../../primitives/Text';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport { Pressable } from '../../primitives/Pressable';\nimport type { IMenuItemProps } from './types';\nimport { MenuContext } from './MenuContext';\nimport { useMenuItem } from './useMenu';\nimport { mergeRefs } from '../../../utils';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\nimport { HStack } from '../../primitives';\n\nconst MenuItem = (\n  { children, isDisabled, onPress, textValue, ...props }: IMenuItemProps,\n  ref: any\n) => {\n  const { closeOnSelect, onClose } = React.useContext(MenuContext);\n  const menuItemRef = React.useRef<any>(null);\n  const mergedRef = mergeRefs([menuItemRef, ref]);\n  const { _text, _stack, ...resolvedProps } = usePropsResolution(\n    'MenuItem',\n    props,\n    {\n      isDisabled,\n    },\n    {\n      cascadePseudoProps: true,\n    }\n  );\n  const [textContent, setTextContent] = React.useState('');\n  React.useEffect(() => {\n    const menuItem = menuItemRef.current;\n    if (menuItem) {\n      setTextContent((menuItem.textContent ?? '').trim());\n    }\n  }, [children]);\n\n  const menuItemProps = useMenuItem({\n    textValue: textValue ?? textContent,\n    ref: menuItemRef,\n  });\n\n  //TODO: refactor for responsive prop\n  if (useHasResponsiveProps(props)) {\n    return null;\n  }\n\n  return (\n    <Pressable\n      {...menuItemProps}\n      {...resolvedProps}\n      ref={mergedRef}\n      disabled={isDisabled}\n      accessibilityState={{\n        disabled: isDisabled,\n      }}\n      onPress={(e: any) => {\n        if (!isDisabled) {\n          onPress && onPress(e);\n          if (closeOnSelect) {\n            onClose && onClose();\n          }\n        }\n      }}\n    >\n      <HStack {..._stack}>\n        {React.Children.map(children, (child, index: any) => {\n          if (typeof child === 'string' || typeof child === 'number') {\n            return (\n              <Text key={`menu-item-${index}`} {..._text}>\n                {child}\n              </Text>\n            );\n          } else {\n            return child;\n          }\n        })}\n      </HStack>\n    </Pressable>\n  );\n};\n\nexport default memo(forwardRef(MenuItem));\n","import React, { forwardRef, memo } from 'react';\nimport MenuGroup from './MenuGroup';\nimport type { IMenuOptionGroupProps, IMenuOptionContextProps } from './types';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\n\nexport const MenuOptionContext = React.createContext<IMenuOptionContextProps>({\n  values: [],\n  onChange: (_val) => {},\n  type: 'checkbox',\n});\n\nconst MenuOptionGroup = (\n  { type, defaultValue, value, onChange, ...props }: IMenuOptionGroupProps,\n  ref?: any\n) => {\n  const internalDefaultValue = defaultValue\n    ? Array.isArray(defaultValue)\n      ? defaultValue\n      : [defaultValue]\n    : [];\n\n  const [internalValues, setValues] = React.useState<Array<string | number>>(\n    internalDefaultValue\n  );\n  const _onChange = (newValue: string | number) => {\n    if (type === 'checkbox') {\n      const newValues = [...internalValues];\n      if (internalValues.includes(newValue)) {\n        newValues.splice(newValues.indexOf(newValue), 1);\n        setValues(newValues);\n      } else {\n        newValues.push(newValue);\n        setValues(newValues);\n      }\n      onChange && onChange(newValues);\n    } else if (type === 'radio') {\n      setValues([newValue]);\n      onChange && onChange(newValue);\n    }\n  };\n  //TODO: refactor for responsive prop\n  if (useHasResponsiveProps(props)) {\n    return null;\n  }\n  return (\n    <MenuOptionContext.Provider\n      value={{\n        values: !value\n          ? internalValues\n          : Array.isArray(value)\n          ? value\n          : [value],\n        onChange: _onChange,\n        type,\n      }}\n    >\n      <MenuGroup {...props} ref={ref} />\n    </MenuOptionContext.Provider>\n  );\n};\n\nexport default memo(forwardRef(MenuOptionGroup));\n","import React, { forwardRef, memo, useContext } from 'react';\nimport { CheckIcon } from '../../primitives/Icon/Icons';\nimport Text from '../../primitives/Text';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport MenuItem from './MenuItem';\nimport type { IMenuItemOptionProps, IMenuOptionContextProps } from './types';\nimport { MenuOptionContext } from './MenuOptionGroup';\nimport { useMenuOptionItem } from './useMenu';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\n\nconst MenuItemOption = (\n  { value, ...props }: IMenuItemOptionProps,\n  ref: any\n) => {\n  const { values, onChange, type }: IMenuOptionContextProps = useContext(\n    MenuOptionContext\n  );\n  const isChecked = values.includes(value);\n  const menuOptionProps = useMenuOptionItem({ isChecked, type });\n  const {\n    children,\n    onPress,\n    _icon,\n    _text,\n    ...resolvedProps\n  } = usePropsResolution('MenuItem', props, { isChecked });\n\n  const modifiedOnPress = (e: any) => {\n    onChange(value);\n    onPress && onPress(e);\n  };\n\n  //TODO: refactor for responsive prop\n  if (useHasResponsiveProps(props)) {\n    return null;\n  }\n  return (\n    <MenuItem\n      {...resolvedProps}\n      {...menuOptionProps}\n      accessibilityRole=\"button\"\n      onPress={modifiedOnPress}\n      ref={ref}\n    >\n      <CheckIcon {..._icon} />\n      {React.Children.map(children, (child, index: any) => {\n        if (typeof child === 'string' || typeof child === 'number') {\n          return (\n            <Text key={`menu-item-option-${index}`} {..._text}>\n              {child}\n            </Text>\n          );\n        } else {\n          return child;\n        }\n      })}\n    </MenuItem>\n  );\n};\n\nexport default memo(forwardRef(MenuItemOption));\n","import { default as MenuMain } from './Menu';\nimport MenuGroup from './MenuGroup';\nimport MenuItem from './MenuItem';\nimport MenuItemOption from './MenuItemOption';\nimport MenuOptionGroup from './MenuOptionGroup';\nimport type { IMenuComponent } from './types';\n\nlet MenuTemp: any = MenuMain;\nMenuTemp.Item = MenuItem;\nMenuTemp.Group = MenuGroup;\nMenuTemp.ItemOption = MenuItemOption;\nMenuTemp.OptionGroup = MenuOptionGroup;\n\n// To add typings\nconst Menu = MenuTemp as IMenuComponent;\n\nexport { Menu };\nexport type {\n  IMenuProps,\n  IMenuItemProps,\n  IMenuItemOptionProps,\n  IMenuGroupProps,\n  IMenuOptionGroupProps,\n} from './types';\n","import React from 'react';\nimport { useOverlayPosition } from '@react-native-aria/overlays';\nimport { StyleSheet, View, ViewStyle } from 'react-native';\nimport type {\n  IPopperProps,\n  IScrollContentStyle,\n  IArrowStyles,\n  IPopoverArrowProps,\n} from './types';\nimport { createContext } from '../../../utils';\nimport Box, { IBoxProps } from '../../primitives/Box';\n// import { useSafeAreaInsets } from 'react-native-safe-area-context';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\n\nconst defaultArrowHeight = 15;\nconst defaultArrowWidth = 15;\n\nconst getDiagonalLength = (height: number, width: number) => {\n  return Math.pow(height * height + width * width, 0.5);\n};\n\ntype PopperContext = IPopperProps & {\n  triggerRef: any;\n  onClose: any;\n  setOverlayRef?: (overlayRef: any) => void;\n};\n\nconst [PopperProvider, usePopperContext] = createContext<PopperContext>(\n  'PopperContext'\n);\n\nconst Popper = (\n  props: IPopperProps & {\n    triggerRef: any;\n    onClose: any;\n    setOverlayRef?: (overlayRef: any) => void;\n  }\n) => {\n  return <PopperProvider {...props}>{props.children}</PopperProvider>;\n};\n\nconst PopperContent = React.forwardRef(\n  ({ children, style, ...rest }: IBoxProps & { isOpen: boolean }, ref: any) => {\n    const {\n      triggerRef,\n      shouldFlip,\n      crossOffset,\n      offset,\n      placement: placementProp,\n      onClose,\n      shouldOverlapWithTrigger,\n      setOverlayRef,\n    } = usePopperContext('PopperContent');\n    const overlayRef = React.useRef(null);\n\n    // const { top } = useSafeAreaInsets();\n    const {\n      overlayProps,\n      rendered,\n      arrowProps,\n      placement,\n    } = useOverlayPosition({\n      targetRef: triggerRef,\n      overlayRef,\n      shouldFlip: shouldFlip,\n      crossOffset: crossOffset,\n      isOpen: rest.isOpen,\n      offset: offset,\n      placement: placementProp as any,\n      containerPadding: 0,\n      onClose: onClose,\n      shouldOverlapWithTrigger,\n    });\n\n    const restElements: React.ReactNode[] = [];\n    let arrowElement: React.ReactElement | null = null;\n\n    React.useEffect(() => {\n      setOverlayRef && setOverlayRef(overlayRef);\n    }, [overlayRef, setOverlayRef]);\n\n    // Might have performance impact if there are a lot of siblings!\n    // Shouldn't be an issue with popovers since it would have atmost 2. Arrow and Content.\n    React.Children.forEach(children, (child) => {\n      if (\n        React.isValidElement(child) &&\n        // @ts-ignore\n        child.type.displayName === 'PopperArrow'\n      ) {\n        arrowElement = React.cloneElement(child, {\n          // @ts-ignore\n          arrowProps,\n          actualPlacement: placement,\n        });\n      } else {\n        restElements.push(child);\n      }\n    });\n\n    let arrowHeight = 0;\n    let arrowWidth = 0;\n\n    if (arrowElement) {\n      arrowHeight = defaultArrowHeight;\n      arrowWidth = defaultArrowWidth;\n\n      //@ts-ignore\n      if (arrowElement.props.height) {\n        //@ts-ignore\n        arrowHeight = arrowElement.props.height;\n      }\n\n      //@ts-ignore\n      if (arrowElement.props.width) {\n        //@ts-ignore\n        arrowWidth = arrowElement.props.width;\n      }\n    }\n\n    const containerStyle = React.useMemo(\n      () =>\n        getContainerStyle({\n          placement,\n          arrowHeight,\n          arrowWidth,\n        }),\n      [arrowHeight, arrowWidth, placement]\n    );\n\n    const overlayStyle = React.useMemo(\n      () =>\n        StyleSheet.create({\n          overlay: {\n            ...overlayProps.style,\n            // To handle translucent android StatusBar\n            // marginTop: Platform.select({ android: top, default: 0 }),\n            opacity: rendered ? 1 : 0,\n            position: 'absolute',\n          },\n        }),\n      [rendered, overlayProps.style]\n    );\n    //TODO: refactor for responsive prop\n    if (useHasResponsiveProps(rest)) {\n      return null;\n    }\n\n    return (\n      <View ref={overlayRef} collapsable={false} style={overlayStyle.overlay}>\n        {arrowElement}\n        <Box\n          style={StyleSheet.flatten([containerStyle, style])}\n          {...rest}\n          ref={ref}\n        >\n          {restElements}\n        </Box>\n      </View>\n    );\n  }\n);\n\n// This is an internal implementation of PopoverArrow\nconst PopperArrow = React.forwardRef(\n  (\n    {\n      height = defaultArrowHeight,\n      width = defaultArrowWidth,\n\n      //@ts-ignore - Will be passed by React.cloneElement from PopperContent\n      arrowProps,\n      //@ts-ignore - Will be passed by React.cloneElement from PopperContent\n      actualPlacement,\n      style,\n      borderColor = '#52525b',\n      backgroundColor = 'black',\n      ...rest\n    }: IPopoverArrowProps & IBoxProps<IPopoverArrowProps>,\n    ref: any\n  ) => {\n    const additionalStyles = React.useMemo(\n      () => getArrowStyles({ placement: actualPlacement, height, width }),\n      [actualPlacement, height, width]\n    );\n\n    const triangleStyle: ViewStyle = React.useMemo(\n      () => ({\n        position: 'absolute',\n        width,\n        height,\n      }),\n      [width, height]\n    );\n\n    const arrowStyles = React.useMemo(\n      () => [arrowProps.style, triangleStyle, additionalStyles, style],\n      [triangleStyle, additionalStyles, arrowProps.style, style]\n    );\n\n    return (\n      <Box\n        ref={ref}\n        style={arrowStyles}\n        borderColor={borderColor}\n        backgroundColor={backgroundColor}\n        zIndex={1}\n        {...rest}\n      />\n    );\n  }\n);\n\nconst getArrowStyles = (props: IArrowStyles) => {\n  const additionalStyles: any = {\n    transform: [],\n  };\n\n  const diagonalLength = getDiagonalLength(\n    defaultArrowHeight,\n    defaultArrowHeight\n  );\n\n  if (props.placement === 'top' && props.width) {\n    additionalStyles.transform.push({ translateX: -props.width / 2 });\n    additionalStyles.transform.push({ rotate: '45deg' });\n    additionalStyles.bottom = Math.ceil(\n      (diagonalLength - defaultArrowHeight) / 2\n    );\n    additionalStyles.borderBottomWidth = 1;\n    additionalStyles.borderRightWidth = 1;\n  }\n\n  if (props.placement === 'bottom' && props.width) {\n    additionalStyles.transform.push({ translateX: -props.width / 2 });\n    additionalStyles.transform.push({ rotate: '45deg' });\n    additionalStyles.top = Math.ceil((diagonalLength - defaultArrowHeight) / 2);\n    additionalStyles.borderTopWidth = 1;\n    additionalStyles.borderLeftWidth = 1;\n  }\n\n  if (props.placement === 'left' && props.height) {\n    additionalStyles.transform.push({ translateY: -props.height / 2 });\n    additionalStyles.transform.push({ rotate: '45deg' });\n    additionalStyles.right = Math.ceil(\n      (diagonalLength - defaultArrowHeight) / 2\n    );\n    additionalStyles.borderTopWidth = 1;\n    additionalStyles.borderRightWidth = 1;\n  }\n\n  if (props.placement === 'right' && props.height) {\n    additionalStyles.transform.push({ translateY: -props.height / 2 });\n    additionalStyles.transform.push({ rotate: '45deg' });\n    additionalStyles.left = Math.ceil(\n      (diagonalLength - defaultArrowHeight) / 2\n    );\n    additionalStyles.borderBottomWidth = 1;\n    additionalStyles.borderLeftWidth = 1;\n  }\n\n  return additionalStyles;\n};\n\nconst getContainerStyle = ({ placement, arrowHeight }: IScrollContentStyle) => {\n  const diagonalLength = getDiagonalLength(arrowHeight, arrowHeight) / 2;\n\n  if (placement === 'top') {\n    return { marginBottom: diagonalLength };\n  }\n\n  if (placement === 'bottom') {\n    return { marginTop: diagonalLength };\n  }\n\n  if (placement === 'left') {\n    return { marginRight: diagonalLength };\n  }\n\n  if (placement === 'right') {\n    return { marginLeft: diagonalLength };\n  }\n\n  return {};\n};\n\nPopperArrow.displayName = 'PopperArrow';\nPopper.Content = PopperContent;\nPopper.Arrow = PopperArrow;\n\nexport { Popper };\n","import { memo } from 'react';\nimport type { IHiddenProps } from './types';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport { useBreakpointValue, useTheme, useToken } from '../../../hooks';\nimport { useColorMode } from '../../../core/color-mode/hooks';\nimport { Platform } from 'react-native';\n\nexport function Hidden({ children, ...props }: IHiddenProps) {\n  const { from, till, only, platform, colorMode } = usePropsResolution(\n    'Hidden',\n    props,\n    {},\n    {\n      ignoreProps: ['only', 'platform'],\n    }\n  );\n  const { breakpoints } = useTheme();\n  const currentColorMode = useColorMode();\n\n  const breakpointValueObject = Object.keys(breakpoints).reduce(\n    (obj: any, val: string) => {\n      obj[val] = val;\n      return obj;\n    },\n    {}\n  );\n  const breakpointValue = useBreakpointValue(breakpointValueObject);\n  const [currentBreakpointValue] = useToken('breakpoints', [breakpointValue]);\n  const [fromBreakPointValue] = useToken('breakpoints', [from]);\n  const [tillBreakPointValue] = useToken('breakpoints', [till]);\n\n  //if no prop is passed, it will hide the element wrapped with hidden\n  if (!from && !till && !only && !colorMode && !platform) {\n    return null;\n  }\n\n  //if from and till prop exists, it will hide the element wrapped accordingly\n  else if (\n    from &&\n    till &&\n    currentBreakpointValue >= fromBreakPointValue &&\n    currentBreakpointValue < tillBreakPointValue\n  ) {\n    return null;\n  }\n\n  //if from prop exists, it will hide the element wrapped starting from that breakpoint.\n  else if (from && !till && currentBreakpointValue >= fromBreakPointValue) {\n    return null;\n  }\n\n  //if till prop exists, it will hide the element wrapped starting from  0 till that breakpoint.\n  else if (till && !from && currentBreakpointValue < tillBreakPointValue) {\n    return null;\n  }\n\n  //if only prop exists and is array, check that array consists current breakpoint value, and if that exists, hide on that breakpoint to next breakpoint.\n  // if only prop is string, hide on that breakpoint to next breakpoint.\n  else if (\n    (Array.isArray(only) && only.includes(breakpointValue)) ||\n    only === breakpointValue\n  ) {\n    return null;\n  }\n  //if platform prop exists and is array, check that array consists current platform value, and if that exists, hide on that platform.\n  // if platform prop is string, hide on that platform.\n  else if (\n    (Array.isArray(platform) && platform.includes(Platform.OS)) ||\n    platform === Platform.OS\n  ) {\n    return null;\n  }\n  //if colormode prop is valid string, hide on that colormode.\n  else if (colorMode === currentColorMode.colorMode) {\n    return null;\n  }\n  return children;\n}\n\nexport default memo(Hidden);\nexport type { IHiddenProps };\n","import { createIcon } from '../createIcon';\n\nexport const CheckIcon = createIcon({\n  viewBox: '0 0 24 24',\n  d:\n    'M8.53115 15.1856L3.96198 10.744L2 12.6512L8.53115 19L22 5.9072L20.038 4L8.53115 15.1856Z',\n});\n\nexport const CheckCircleIcon = createIcon({\n  viewBox: '0 0 24 24',\n  d:\n    'M12 24C18.6274 24 24 18.6274 24 12C24 5.37258 18.6274 0 12 0C5.37258 0 0 5.37258 0 12C0 18.6274 5.37258 24 12 24ZM7.17719 11.2464L9.91869 13.9114L16.8228 7.2L18 8.34432L9.91869 16.2L6 12.3907L7.17719 11.2464Z',\n});\n","import React from 'react';\nimport { G, Path } from '../nbSvg';\n\nexport const questionOutlineIconPath = (\n  <G>\n    <Path d=\"M12 20.75C9.67936 20.75 7.45376 19.8281 5.81282 18.1872C4.17187 16.5462 3.25 14.3206 3.25 12C3.25 9.67936 4.17187 7.45376 5.81282 5.81282C7.45376 4.17187 9.67936 3.25 12 3.25C14.3206 3.25 16.5462 4.17187 18.1872 5.81282C19.8281 7.45376 20.75 9.67936 20.75 12C20.75 14.3206 19.8281 16.5462 18.1872 18.1872C16.5462 19.8281 14.3206 20.75 12 20.75ZM12 22C14.6522 22 17.1957 20.9464 19.0711 19.0711C20.9464 17.1957 22 14.6522 22 12C22 9.34784 20.9464 6.8043 19.0711 4.92893C17.1957 3.05357 14.6522 2 12 2C9.34784 2 6.8043 3.05357 4.92893 4.92893C3.05357 6.8043 2 9.34784 2 12C2 14.6522 3.05357 17.1957 4.92893 19.0711C6.8043 20.9464 9.34784 22 12 22Z\" />\n    <Path d=\"M8.70533 9.34281C8.70369 9.38156 8.70999 9.42024 8.72385 9.45647C8.73771 9.4927 8.75883 9.52571 8.78592 9.55347C8.81301 9.58123 8.84549 9.60316 8.88136 9.6179C8.91724 9.63265 8.95575 9.6399 8.99453 9.63921H9.98453C10.1501 9.63921 10.2821 9.50361 10.3037 9.33921C10.4117 8.55201 10.9517 7.97841 11.9141 7.97841C12.7373 7.97841 13.4909 8.39001 13.4909 9.38001C13.4909 10.142 13.0421 10.4924 12.3329 11.0252C11.5253 11.612 10.8857 12.2972 10.9313 13.4096L10.9349 13.67C10.9362 13.7487 10.9684 13.8238 11.0245 13.879C11.0806 13.9343 11.1562 13.9652 11.2349 13.9652H12.2081C12.2877 13.9652 12.364 13.9336 12.4203 13.8773C12.4765 13.8211 12.5081 13.7448 12.5081 13.6652V13.5392C12.5081 12.6776 12.8357 12.4268 13.7201 11.756C14.4509 11.2004 15.2129 10.5836 15.2129 9.28881C15.2129 7.47561 13.6817 6.59961 12.0053 6.59961C10.4849 6.59961 8.81933 7.30761 8.70533 9.34281ZM10.5737 16.2584C10.5737 16.898 11.0837 17.3708 11.7857 17.3708C12.5165 17.3708 13.0193 16.898 13.0193 16.2584C13.0193 15.596 12.5153 15.1304 11.7845 15.1304C11.0837 15.1304 10.5737 15.596 10.5737 16.2584Z\" />\n  </G>\n);\n","import React, { memo, forwardRef } from 'react';\nimport { useToken, usePropsResolution } from '../../../hooks';\nimport { makeStyledComponent } from '../../../utils/styled';\nimport { Svg, G } from './nbSvg';\nimport type { IIconProps } from './types';\nimport { questionOutlineIconPath } from './Icons/questionIconPath';\nimport { useHasResponsiveProps } from '../../../hooks/useHasResponsiveProps';\n\nconst SVG = makeStyledComponent(Svg);\n\nconst SVGIcon = ({ children, ...props }: IIconProps, ref: any) => {\n  const {\n    focusable,\n    stroke,\n    color,\n    size,\n    ...resolvedProps\n  } = usePropsResolution('Icon', props);\n  const strokeHex = useToken('colors', stroke || '');\n  const colorHex = useToken('colors', color || '');\n  //TODO: refactor for responsive prop\n  if (useHasResponsiveProps(props)) {\n    return null;\n  }\n  return (\n    <SVG\n      {...resolvedProps}\n      // height={\n      //   newProps.size\n      //     ? parseInt(newProps.size, 10)\n      //     : parseInt(newProps.height, 10)\n      // }\n      // width={\n      //   newProps.size\n      //     ? parseInt(newProps.size, 10)\n      //     : parseInt(newProps.width, 10)\n      // }\n      size={size}\n      color={colorHex}\n      stroke={strokeHex}\n      focusable={focusable}\n      accessibilityRole=\"image\"\n      // style={style}\n      ref={ref}\n    >\n      {React.Children.count(children) > 0 ? (\n        <G>\n          {React.Children.map(children, (child, i) => (\n            <ChildPath\n              key={child?.key ?? i}\n              element={child}\n              {...child?.props}\n            />\n          ))}\n        </G>\n      ) : (\n        questionOutlineIconPath\n      )}\n    </SVG>\n  );\n};\nconst ChildPath = ({ element, fill, stroke: pathStroke }: any) => {\n  const pathStrokeColor = useToken('colors', pathStroke || '');\n  const fillColor = useToken('colors', fill || '');\n\n  if (!element) {\n    return null;\n  }\n\n  return React.cloneElement(element, {\n    fill: fillColor ? fillColor : 'currentColor',\n    stroke: pathStrokeColor,\n  });\n};\nexport default memo(forwardRef(SVGIcon));\n","import React, { memo, forwardRef } from 'react';\nimport SVGIcon from './SVGIcon';\nimport { Path } from './nbSvg';\nimport type { IcreateIconProps } from './types';\nimport isEmpty from 'lodash.isempty';\n\nexport const createIcon = ({ path, d, ...initialProps }: IcreateIconProps) => {\n  const createdIcon = (props: any, ref: any) => {\n    let children = path;\n    if (d && (!path || isEmpty(path))) {\n      children = <Path fill=\"currentColor\" d={d} />;\n    }\n    return (\n      <SVGIcon children={children} {...initialProps} {...props} ref={ref} />\n    );\n  };\n  return memo(forwardRef(createdIcon));\n};\n","//@ts-ignore\nimport { unstable_createElement } from 'react-native-web';\nimport { forwardRef } from 'react';\n\nexport const Svg = forwardRef((props: any, ref: any) =>\n  unstable_createElement('svg', { ...props, ref })\n);\nexport const G = forwardRef((props: any, ref: any) =>\n  unstable_createElement('g', { ...props, ref })\n);\nexport const Path = forwardRef((props: any, ref: any) =>\n  unstable_createElement('path', { ...props, ref })\n);\nexport const Polygon = forwardRef((props: any, ref: any) =>\n  unstable_createElement('polygon', { ...props, ref })\n);\nexport const Line = forwardRef((props: any, ref: any) =>\n  unstable_createElement('line', { ...props, ref })\n);\nexport const Circle = forwardRef((props: any, ref: any) =>\n  unstable_createElement('circle', { ...props, ref })\n);\nexport const Rect = forwardRef((props: any, ref: any) =>\n  unstable_createElement('rect', { ...props, ref })\n);\n","import { useWindowDimensions } from 'react-native';\nimport {\n  getClosestBreakpoint,\n  hasValidBreakpointFormat,\n  findLastValidBreakpoint,\n} from '../theme/tools';\nimport { useTheme } from './../hooks/useTheme';\nimport type { ITheme } from '../theme/index';\n\ntype UseBreakpointValueParam =\n  | { [key in keyof ITheme['breakpoints']]?: any }\n  | Array<any>;\n\nexport function useBreakpointValue(values: UseBreakpointValueParam) {\n  let windowWidth = useWindowDimensions()?.width;\n  const theme = useTheme();\n\n  if (hasValidBreakpointFormat(values, theme.breakpoints)) {\n    let currentBreakpoint = getClosestBreakpoint(\n      theme.breakpoints,\n      windowWidth\n    );\n    return findLastValidBreakpoint(\n      values,\n      theme.breakpoints,\n      currentBreakpoint\n    );\n  } else {\n    return values;\n  }\n}\n","import React from 'react';\n\nexport function useControllableProp<T>(prop: T | undefined, state: T) {\n  const { current: isControlled } = React.useRef(prop !== undefined);\n  const value = isControlled && typeof prop !== 'undefined' ? prop : state;\n  return [isControlled, value] as const;\n}\n\nexport interface UseControllableStateProps<T> {\n  /**\n   * The value to used in controlled mode\n   */\n  value?: T;\n  /**\n   * The initial value to be used, in uncontrolled mode\n   */\n  defaultValue?: T | (() => T);\n  /**\n   * The callback fired when the value changes\n   */\n  onChange?: (value: T) => void;\n  /**\n   * The component name (for warnings)\n   */\n  name?: string;\n}\n\n/**\n * React hook for using controlling component state.\n * @param props\n */\nexport function useControllableState<T>(props: UseControllableStateProps<T>) {\n  const { value: valueProp, defaultValue, onChange } = props;\n\n  const [valueState, setValue] = React.useState(defaultValue as T);\n  const isControlled = valueProp !== undefined;\n\n  const value = isControlled ? (valueProp as T) : valueState;\n\n  const updateValue = React.useCallback(\n    (next: any) => {\n      const nextValue = typeof next === 'function' ? next(value) : next;\n      if (!isControlled) {\n        setValue(nextValue);\n      }\n      onChange && onChange(nextValue);\n    },\n    [isControlled, onChange, value]\n  );\n\n  return [value, updateValue] as [T, React.Dispatch<React.SetStateAction<T>>];\n}\n","import { useTheme } from './useTheme';\nimport get from 'lodash.get';\n\nexport function useToken<T extends string | number>(\n  property: string,\n  token: T | T[],\n  fallback?: T | T[]\n) {\n  const theme = useTheme();\n  if (Array.isArray(token)) {\n    let fallbackArr: T[] = [];\n    if (fallback) {\n      fallbackArr = Array.isArray(fallback) ? fallback : [fallback];\n    }\n    return token.map((innerToken, index) => {\n      const path = `${property}.${innerToken}`;\n      return get(theme, path, fallbackArr[index] ?? innerToken);\n    });\n  }\n\n  const path = `${property}.${token}`;\n  return get(theme, path, fallback ?? token);\n}\n"],"names":["Backdrop","props","useHasResponsiveProps","React","Pressable","_web","cursor","position","top","bottom","left","right","accessible","importantForAccessibility","bg","opacity","memo","FocusContext","Set","focusableElements","join","push","FocusableContext","ref","children","otherProps","_babelRuntimeHelpersEsmObjectWithoutPropertiesLoose","context","_react","$e11539c8317b2d21639df611cb5658f$var$FocusableContext","Provider","value","useMenu","focusManager","useContext","onKeyDown","e","key","preventDefault","focusNext","wrap","focusPrevious","accessibilityRole","ITEM_ATTR","getValue","element","getAttribute","MenuContext","closeOnSelect","onClose","Menu","trigger","onOpen","isOpenProp","isOpen","defaultIsOpen","placement","triggerRef","useControllableState","defaultValue","onChange","setIsOpen","usePropsResolution","_overlay","_presenceTransition","_backdrop","useRNModal","resolvedProps","handleOpen","handleClose","triggerProps","menuTriggerId","uniqueId","ResponsiveQueryContext","disableCSSMediaQueries","useId","event","includes","undefined","useMenuTrigger","AccessibilityInfo","onPress","open","Overlay","onRequestClose","useRNModalOnAndroid","unmountOnExit","PresenceTransition","visible","Popper","FocusScope","contain","restoreFocus","autoFocus","MenuContent","menuRef","menuProps","typeaheadProps","length","ctrlKey","altKey","metaKey","container","currentTarget","values","Array","from","querySelectorAll","map","searchKey","foundValue","find","toLowerCase","startsWith","newItem","querySelector","setTimeout","focus","useMenuTypeahead","Box","ScrollView","forwardRef","MenuGroup","title","_title","Text","MenuItem","isDisabled","textValue","menuItemRef","mergedRef","mergeRefs","cascadePseudoProps","_text","_stack","textContent","setTextContent","menuItem","current","trim","menuItemProps","dataSet","nativebaseMenuItem","onHoverIn","Platform","useMenuItem","disabled","accessibilityState","HStack","child","index","MenuOptionContext","_val","type","MenuOptionGroup","internalDefaultValue","isArray","internalValues","setValues","newValue","newValues","splice","indexOf","MenuItemOption","isChecked","menuOptionProps","checked","accessibilityChecked","useMenuOptionItem","_icon","CheckIcon","MenuTemp","MenuMain","Item","Group","ItemOption","OptionGroup","defaultArrowHeight","getDiagonalLength","height","width","Math","pow","createContext","PopperProvider","usePopperContext","PopperContent","style","rest","shouldFlip","crossOffset","offset","placementProp","shouldOverlapWithTrigger","setOverlayRef","overlayRef","useOverlayPosition","targetRef","containerPadding","overlayProps","rendered","arrowProps","restElements","arrowElement","displayName","actualPlacement","arrowHeight","arrowWidth","containerStyle","getContainerStyle","overlayStyle","StyleSheet","overlay","View","collapsable","PopperArrow","borderColor","backgroundColor","additionalStyles","getArrowStyles","triangleStyle","arrowStyles","zIndex","transform","diagonalLength","translateX","rotate","ceil","borderBottomWidth","borderRightWidth","borderTopWidth","borderLeftWidth","translateY","marginBottom","marginTop","marginRight","marginLeft","Content","Arrow","Hidden","ignoreProps","till","only","platform","colorMode","breakpoints","useTheme","currentColorMode","useColorMode","breakpointValueObject","Object","keys","reduce","obj","val","breakpointValue","useBreakpointValue","useToken","currentBreakpointValue","fromBreakPointValue","tillBreakPointValue","createIcon","viewBox","d","CheckCircleIcon","questionOutlineIconPath","G","Path","SVG","makeStyledComponent","Svg","SVGIcon","focusable","stroke","color","size","strokeHex","colorHex","i","ChildPath","fill","pathStroke","pathStrokeColor","fillColor","path","initialProps","createdIcon","isEmpty","unstable_createElement","windowWidth","useWindowDimensions","_useWindowDimensions","theme","hasValidBreakpointFormat","currentBreakpoint","getClosestBreakpoint","findLastValidBreakpoint","valueProp","valueState","setValue","isControlled","updateValue","next","nextValue","property","token","fallback","fallbackArr","innerToken","get"],"sourceRoot":""}